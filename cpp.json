{
    "leetcode": {
        "prefix": "leetcode",
        "body": [
            "#include \"bits/stdc++.h\"",
            "using namespace std;",
            "",
            "auto init = [] () {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    return 0;",
            "}();",
            "",
            "",
            "",
            "void ac() {",
            "    Solution sol;",
            "",
            "}",
            "",
            "signed main() {",
            "    if (fopen(\"in.txt\", \"r\")) {",
            "        freopen(\"in.txt\", \"r\", stdin);",
            "        freopen(\"out.txt\", \"w\", stdout);",
            "    }",
            "    ac();",
            "}"
        ],
        "description": "leetcode"
    },
    "warith": {
        "prefix": "warith",
        "body": [
            "#include \"bits/stdc++.h\"",
            "using namespace std;",
            "",
            "void ac() {",
            "    ${0}",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    if (fopen(\"in.txt\", \"r\")) {",
            "        freopen(\"in.txt\", \"r\", stdin);",
            "        freopen(\"out.txt\", \"w\", stdout);",
            "    }",
            "    int T = 1;",
            "    // cin >> T;",
            "    while (T--) {",
            "        ac();",
            "        if (T) {",
            "            cout << '\\n';",
            "        }",
            "    }",
            "}"
        ],
        "description": "reset"
    },
    "segment_tree": {
        "prefix": "segment_tree",
        "body": [
            "template <class node>",
            "class segment_tree {",
            "    int size;",
            "    vector<node> seg;",
            "",
            "    template <class T>",
            "    void build(int x, int lx, int rx, const vector<T> &nums) {",
            "        if (lx == rx) {",
            "            return seg[x].apply(lx, rx, nums[lx]);",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        build(left, lx, mid, nums);",
            "        build(right, mid + 1, rx, nums);",
            "        seg[x].merge(seg[left], seg[right]);",
            "    }",
            "",
            "    template <class T>",
            "    void update(int x, int lx, int rx, int l, int r, T value) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x].apply(lx, rx, value);",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        seg[x].propagate(lx, rx, seg[left], seg[right]);",
            "        if (l <= mid) {",
            "            update(left, lx, mid, l, r, value);",
            "        }",
            "        if (mid + 1 <= r) {",
            "            update(right, mid + 1, rx, l, r, value);",
            "        }",
            "        seg[x].merge(seg[left], seg[right]);",
            "    }",
            "",
            "    node query(int x, int lx, int rx, int l, int r) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x];",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        seg[x].propagate(lx, rx, seg[left], seg[right]);",
            "        if (r < mid + 1) {",
            "            return query(left, lx, mid, l, r);",
            "        }",
            "        if (mid < l) {",
            "            return query(right, mid + 1, rx, l, r);",
            "        }",
            "        node ret;",
            "        ret.merge(query(left, lx, mid, l, r), query(right, mid + 1, rx, l, r));",
            "        return ret;",
            "    }",
            "",
            "    pair<int, node> find(int x, int lx, int rx, node *last, int l, int r, int dir, const auto &F) {",
            "        if (l <= lx && rx <= r) {",
            "            node cur_node = seg[x];",
            "            if (last) {",
            "                dir ? cur_node.merge(*last, seg[x])",
            "                    : cur_node.merge(seg[x], *last);",
            "            }",
            "            if (!F(cur_node)) {",
            "                return {-1, cur_node};",
            "            }",
            "            if (lx == rx) {",
            "                return {lx, cur_node};",
            "            }",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        seg[x].propagate(lx, rx, seg[left], seg[right]);",
            "        if (r < mid + 1) {",
            "            return find(left, lx, mid, last, l, r, dir, F);",
            "        }",
            "        if (mid < l) {",
            "            return find(right, mid + 1, rx, last, l, r, dir, F);",
            "        }",
            "        auto [idx, nd] = (dir ? find(left, lx, mid, last, l, r, dir, F)",
            "                              : find(right, mid + 1, rx, last, l, r, dir, F));",
            "        if (~idx) {",
            "            return {idx, nd};",
            "        }",
            "        return dir ? find(right, mid + 1, rx, &nd, l, r, dir, F)",
            "                   : find(left, lx, mid, &nd, l, r, dir, F);",
            "    }",
            "",
            "public:",
            "    template <class T>",
            "    segment_tree(int n, T val) {",
            "        size = n;",
            "        seg.resize(2 * size - 1);",
            "        build(0, 0, size - 1, vector<T>(n, val));",
            "    }",
            "",
            "    template <class T>",
            "    segment_tree(const vector<T> &nums) {",
            "        size = nums.size();",
            "        seg.resize(2 * size - 1);",
            "        build(0, 0, size - 1, nums);",
            "    }",
            "",
            "    template <class T>",
            "    void update(int l, int r, T value) {",
            "        update(0, 0, size - 1, l, r, value);",
            "    }",
            "",
            "    node query(int l, int r) {",
            "        return query(0, 0, size - 1, l, r);",
            "    }",
            "",
            "    int find_first(int l, int r, const auto &F) {",
            "        return find(0, 0, size - 1, nullptr, l, r, 1, F).first;",
            "    }",
            "",
            "    int find_last(int l, int r, const auto &F) {",
            "        return find(0, 0, size - 1, nullptr, l, r, 0, F).first;",
            "    }",
            "};",
            "",
            "struct node {",
            "    int64_t sum = 0, lazy = -1;",
            "",
            "    void apply(int lx, int rx, int64_t val = 0) {",
            "    }",
            "",
            "    void merge(const node &a, const node &b) {",
            "    }",
            "",
            "    void propagate(int lx, int rx, node &left, node &right) {",
            "        int mid = lx + rx >> 1;",
            "        if (~lazy) {",
            "            left.apply(lx, mid, lazy);",
            "            right.apply(mid + 1, rx, lazy);",
            "            lazy = -1;",
            "        }",
            "    }",
            "};"
        ],
        "description": "segment_tree"
    },
    "sparse_table": {
        "prefix": "sparse_table",
        "body": [
            "template <typename T>",
            "class sparse_table {",
            "    vector<vector<T>> dp;",
            "",
            "    T merge(T x, T y) {",
            "        return __gcd(x, y);",
            "    }",
            "",
            "public:",
            "    sparse_table(vector<T> const &v) {",
            "        int n = v.size(), LOG = __lg(n) + 1;",
            "        dp = vector(n, vector<T>(LOG, T{}));",
            "        for (int i = 0; i < n; ++i) {",
            "            dp[i][0] = v[i];",
            "        }",
            "",
            "        for (int bit = 1; bit < LOG; ++bit) {",
            "            for (int i = 0; i + (1 << bit) <= n; ++i) {",
            "                dp[i][bit] = merge(dp[i][bit - 1],",
            "                                   dp[i + (1 << (bit - 1))][bit - 1]);",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int l, int r) { // min, max, gcd, lcm, and, or",
            "        int x = __lg(r - l + 1);",
            "        return merge(dp[l][x], dp[r - (1 << x) + 1][x]);",
            "    }",
            "};",
            ""
        ],
        "description": "sparse_table"
    },
    "kmp": {
        "prefix": "kmp",
        "body": [
            "vector<int> prefix_function(const string &s) {",
            "    int n = s.size();",
            "    vector<int> pi(n, 0);",
            "    for (int i = 1, j = 0; i < n; ++i) {",
            "        while (j > 0 && s[i] != s[j])",
            "            j = pi[j - 1];",
            "        if (s[i] == s[j])",
            "            ++j;",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}",
            "",
            "vector<int> kmp(const string &s, const string &pat) {",
            "    int n = s.size();",
            "    auto pi = prefix_function(pat);",
            "    vector<int> ret(n, 0);",
            "    for (int i = 0, j = 0; i < n; ++i) {",
            "        while (j > 0 && s[i] != pat[j])",
            "            j = pi[j - 1];",
            "        if (s[i] == pat[j])",
            "            ++j;",
            "        if (j == (int)pat.size())",
            "            j = pi[j - 1], ret[i - (int)pat.size() + 1] = 1;",
            "    }",
            "    return ret;",
            "}"
        ],
        "description": "kmp"
    },
    "z_function": {
        "prefix": "z_function",
        "body": [
            "vector<int> z_function(const string &s) {",
            "    int n = s.size();",
            "    vector<int> z(n);",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; i++) {",
            "        if (i < r) {",
            "            z[i] = min(r - i, z[i - l]);",
            "        }",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
            "            z[i]++;",
            "        }",
            "        if (i + z[i] > r) {",
            "            l = i;",
            "            r = i + z[i];",
            "        }",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "z_function"
    },
    "trie": {
        "prefix": "trie",
        "body": [
            "class trie {",
            "private:",
            "    struct node {",
            "        int child[26];",
            "        int word = 0, prefix = 0;",
            "        node() {",
            "            fill(begin(child), end(child), -1);",
            "        }",
            "    };",
            "",
            "    vector<node> tree = vector<node>(1);",
            "",
            "public:",
            "    void insert(const string &s, int cnt = 1) {",
            "        int cur = 0;",
            "        for (auto it : s) {",
            "            int to = it - 'a';",
            "            if (tree[cur].child[to] == -1) {",
            "                tree[cur].child[to] = tree.size();",
            "                tree.emplace_back(node());",
            "            }",
            "            cur = tree[cur].child[to];",
            "            tree[cur].prefix += cnt;",
            "        }",
            "        tree[cur].word += cnt;",
            "    }",
            "",
            "    void erase(const string &s) {",
            "        int cur = 0;",
            "        for (auto it : s) {",
            "            int to = it - 'a';",
            "            if (tree[cur].child[to] == -1 || tree[tree[cur].child[to]].prefix == 1) {",
            "                tree[cur].child[to] = -1;",
            "                return;",
            "            }",
            "            cur = tree[cur].child[to];",
            "            tree[cur].prefix--;",
            "        }",
            "        tree[cur].word--;",
            "    }",
            "",
            "    int count_word(const string &s) {",
            "        int cur = 0;",
            "        for (auto it : s) {",
            "            int to = it - 'a';",
            "            if (tree[cur].child[to] == -1) {",
            "                return 0;",
            "            }",
            "            cur = tree[cur].child[to];",
            "        }",
            "        return tree[cur].word;",
            "    }",
            "",
            "    int count_prefix(const string &s) {",
            "        int cur = 0;",
            "        for (auto it : s) {",
            "            int to = it - 'a';",
            "            if (tree[cur].child[to] == -1) {",
            "                return 0;",
            "            }",
            "            cur = tree[cur].child[to];",
            "        }",
            "        return tree[cur].prefix;",
            "    }",
            "};",
            ""
        ],
        "description": "Trie"
    },
    "binary_trie": {
        "prefix": "binary_trie",
        "body": [
            "template <int LOG = 62>",
            "class binary_trie {",
            "private:",
            "    struct node {",
            "        int64_t cnt = 0;",
            "        int child[2] = {-1, -1};",
            "    };",
            "    vector<node> tree = vector<node>(1);",
            "",
            "    bool valid(int node) { return node != -1 && 0 < tree[node].cnt; }",
            "",
            "public:",
            "    void insert(int64_t x, int cnt = 1) {",
            "        int cur = 0;",
            "        tree[cur].cnt += cnt;",
            "        for (int bit = LOG; ~bit; --bit) {",
            "            int to = (x >> bit) & 1;",
            "            if (tree[cur].child[to] == -1) {",
            "                tree[cur].child[to] = tree.size();",
            "                tree.emplace_back();",
            "            }",
            "            cur = tree[cur].child[to];",
            "            tree[cur].cnt += cnt;",
            "        }",
            "    }",
            "",
            "    int64_t max_xor(int64_t x) {",
            "        int64_t cur = 0, ret = 0;",
            "        for (int bit = LOG; ~bit; bit--) {",
            "            int to = (x >> bit) & 1;",
            "            if (valid(tree[cur].child[!to])) {",
            "                cur = tree[cur].child[!to];",
            "                ret += !to * (1LL << bit);",
            "            } else if (valid(tree[cur].child[to])) {",
            "                cur = tree[cur].child[to];",
            "                ret += to * (1LL << bit);",
            "            }",
            "        }",
            "        return x ^ ret;",
            "    }",
            "",
            "    int64_t min_xor(int64_t x) {",
            "        return ~max_xor(~x);",
            "    }",
            "",
            "    int64_t xor_less_than_k(int64_t x, int64_t k) {",
            "        int64_t cur = 0, ret = 0;",
            "        for (int bit = LOG; ~bit; --bit) {",
            "            if (!valid(cur))",
            "                return ret;",
            "            int to = (x >> bit) & 1;",
            "            if ((k >> bit) & 1) {",
            "                if (valid(tree[cur].child[to])) {",
            "                    ret += tree[tree[cur].child[to]].cnt;",
            "                }",
            "                cur = tree[cur].child[!to];",
            "            } else {",
            "                cur = tree[cur].child[to];",
            "            }",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    int64_t xor_greater_equal_to_k(int64_t x, int64_t k) {",
            "        return tree[0].cnt - xor_less_than_k(x, k);",
            "    }",
            "};"
        ],
        "description": "binary_trie"
    },
    "dr_string": {
        "prefix": "dr_string",
        "body": [
            "class dr_string {",
            "private:",
            "    using i128 = __int128_t;",
            "    static const int64_t MOD = (1LL << 61) - 1;",
            "    static int64_t base;",
            "    vector<int64_t> pow{1}, hash{0};",
            "",
            "    int64_t sub(int64_t a, int64_t b) {",
            "        a -= b;",
            "        if (a < 0) {",
            "            a += MOD;",
            "        }",
            "        return a;",
            "    }",
            "",
            "public:",
            "    dr_string(const auto &s) {",
            "        for (int i = 0; i < s.size(); i++) {",
            "            pow.emplace_back((i128)pow[i] * base % MOD);",
            "            hash.emplace_back(((i128)hash[i] * base + s[i]) % MOD);",
            "        }",
            "    }",
            "",
            "    int64_t substr(int l, int r) {",
            "        return sub(hash[r + 1], (i128)hash[l] * pow[r - l + 1] % MOD);",
            "    }",
            "",
            "    int64_t merge(int64_t h1, int64_t h2, int len2) {",
            "        return ((i128)h1 * pow[len2] + h2) % MOD;",
            "    }",
            "};",
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "int64_t dr_string::base = (MOD >> 2) + rng() % (MOD >> 1);"
        ],
        "description": "dr_string"
    },
    "PST": {
        "prefix": "PST",
        "body": [
            "/* you can set opt to true if update is (assign or single point update)*/",
            "template <class node, int64_t LX = INT_MIN, int64_t RX = INT_MAX, bool opt = false>",
            "class seg_tree {",
            "    vector<node> seg;",
            "    vector<int> roots = {0}, left = {0}, right = {0};",
            "",
            "    void create_node(int &x) {",
            "        if (x && opt) return;",
            "        int y = x;",
            "        x = seg.size();",
            "        seg.emplace_back(seg[y]);",
            "        left.emplace_back(left[y]);",
            "        right.emplace_back(right[y]);",
            "    }",
            "",
            "    template <class... M>",
            "    int update(int x, int64_t lx, int64_t rx, int64_t l, int64_t r, const M &...val) {",
            "        if (rx < l || r < lx) return x;",
            "",
            "        int nd = (opt ? -1 : x);",
            "        if (l <= lx && rx <= r) {",
            "            create_node(nd);",
            "            seg[nd].apply(lx, rx, val...);",
            "            return nd;",
            "        }",
            "",
            "        int64_t mid = lx + rx >> 1;",
            "        create_node(left[x]);",
            "        create_node(right[x]);",
            "        seg[x].propagate(seg[left[x]], seg[right[x]], lx, rx, mid);",
            "",
            "        create_node(nd);",
            "        left[nd] = update(left[x], lx, mid, l, r, val...);",
            "        right[nd] = update(right[x], mid + 1, rx, l, r, val...);",
            "        seg[nd].merge(seg[left[nd]], seg[right[nd]]);",
            "",
            "        return nd;",
            "    }",
            "",
            "    node query(int x, int64_t lx, int64_t rx, int64_t l, int64_t r) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x];",
            "        }",
            "",
            "        int64_t mid = lx + rx >> 1;",
            "        create_node(left[x]);",
            "        create_node(right[x]);",
            "        seg[x].propagate(seg[left[x]], seg[right[x]], lx, rx, mid);",
            "",
            "        if (r < mid + 1) {",
            "            return query(left[x], lx, mid, l, r);",
            "        }",
            "        if (mid < l) {",
            "            return query(right[x], mid + 1, rx, l, r);",
            "        }",
            "        node ret;",
            "        ret.merge(query(left[x], lx, mid, l, r), query(right[x], mid + 1, rx, l, r));",
            "        return ret;",
            "    }",
            "",
            "    pair<int, node> find(int x, int64_t lx, int64_t rx, node *last, int64_t l, int64_t r, int dir, const auto &F) {",
            "        if (l <= lx && rx <= r) {",
            "            node cur_node = seg[x];",
            "            if (last) {",
            "                dir ? cur_node.merge(*last, seg[x]) : cur_node.merge(seg[x], *last);",
            "            }",
            "            if (!F(cur_node)) return {-1, cur_node};",
            "            if (lx == rx) return {lx, cur_node};",
            "        }",
            "",
            "        int64_t mid = lx + rx >> 1;",
            "        create_node(left[x]);",
            "        create_node(right[x]);",
            "        seg[x].propagate(seg[left[x]], seg[right[x]], lx, rx, mid);",
            "",
            "        if (r < mid + 1) {",
            "            return find(left[x], lx, mid, last, l, r, dir, F);",
            "        }",
            "        if (mid < l) {",
            "            return find(right[x], mid + 1, rx, last, l, r, dir, F);",
            "        }",
            "        auto [idx, nd] = (dir ? find(left[x], lx, mid, last, l, r, dir, F) : find(right[x], mid + 1, rx, last, l, r, dir, F));",
            "        if (~idx) return {idx, nd};",
            "        return dir ? find(right[x], mid + 1, rx, &nd, l, r, dir, F) : find(left[x], lx, mid, &nd, l, r, dir, F);",
            "    }",
            "",
            "public:",
            "    seg_tree() { create_node(roots[0]); }",
            "",
            "    int cur_time() { return roots.size() - 1; }",
            "",
            "    void push_back(int time) {",
            "        roots.push_back(roots[time]);",
            "    }",
            "",
            "    template <class... M>",
            "    void update(int time, int64_t l, int64_t r, const M &...val) {",
            "        roots[time] = update(roots[time], LX, RX, l, r, val...);",
            "    }",
            "",
            "    node query(int time, int64_t l, int64_t r) {",
            "        return query(roots[time], LX, RX, l, r);",
            "    }",
            "",
            "    int find_first(int time, int64_t l, int64_t r, const auto &F) {",
            "        return find(roots[time], LX, RX, nullptr, l, r, 1, F).first;",
            "    }",
            "",
            "    int find_last(int time, int64_t l, int64_t r, const auto &F) {",
            "        return find(roots[time], LX, RX, nullptr, l, r, 0, F).first;",
            "    }",
            "};",
            "",
            "struct node {",
            "    int64_t one = 0;",
            "",
            "    void apply(int64_t lx, int64_t rx, int64_t val) {",
            "        one ^= val;",
            "    }",
            "",
            "    void merge(const node &a, const node &b) {",
            "        one = a.one + b.one;",
            "    }",
            "",
            "    void propagate(node &left, node &right, int64_t lx, int64_t rx, int64_t mid) {",
            "        // if (lazy != -1) {",
            "        //     left.apply(lx, mid, lazy);",
            "        //     right.apply(mid + 1, rx, lazy);",
            "        //     lazy = -1;",
            "        // }",
            "    }",
            "};",
            ""
        ],
        "description": "PST"
    },
    "matrix": {
        "prefix": "matrix",
        "body": [
            "const int mod = 1e9 + 7;",
            "template <class T = int64_t>",
            "class matrix : public vector<vector<T>> {",
            "public:",
            "    matrix() : vector<vector<T>>() {}",
            "    matrix(vector<vector<T>> &v) : vector<vector<T>>(v) {}",
            "    matrix(int n, int m, T val = 0) : vector<vector<T>>(n, vector<T>(m, val)) {}",
            "    matrix(initializer_list<initializer_list<T>> init)",
            "        : vector<vector<T>>(init.begin(), init.end()) {}",
            "",
            "    matrix(int n) : matrix(n, n) { // Identity matrix",
            "        for (int i = 0; i < n; ++i) {",
            "            (*this)[i][i] = 1;",
            "        }",
            "    }",
            "",
            "    matrix<T> operator*(const auto &x) const {",
            "        int n = this->size(), m = x[0].size(), k = (*this)[0].size();",
            "        matrix<T> ret(n, m);",
            "        for (int i = 0; i < n; i++) {",
            "            for (int o = 0; o < k; o++) {",
            "                for (int j = 0; j < m; j++) {",
            "                    ret[i][j] += (*this)[i][o] * x[o][j];",
            "                    if (ret[i][j] >= mod) {",
            "                        ret[i][j] -= mod;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    matrix<T> power(int64_t p) {",
            "        matrix<T> ret(this->size()), base(*this);",
            "        while (p) {",
            "            if (p & 1) {",
            "                ret = ret * base;",
            "            }",
            "            base = base * base;",
            "            p >>= 1;",
            "        }",
            "        return ret;",
            "    }",
            "};",
            ""
        ],
        "description": "matrix"
    },
    "power": {
        "prefix": "power",
        "body": [
            "const int mod = 1e9 + 7;",
            "int64_t power(int64_t a, int64_t b, const int MOD = mod) {",
            "    a %= MOD;",
            "    int64_t s = 1;",
            "    while (b) {",
            "        if (b % 2 == 1)",
            "            s = s * a % MOD;",
            "        a = a * a % MOD;",
            "        b /= 2;",
            "    }",
            "    return s;",
            "}"
        ],
        "description": "power"
    },
    "min_priority_queue": {
        "prefix": "min_priority_queue",
        "body": [
            "template<class T>",
            "using min_priority_queue = priority_queue<T, vector<T>, greater<>>;"
        ],
        "description": "min_priority_queue"
    },
    "rope": {
        "prefix": "rope",
        "body": [
            "#include <ext/rope>",
            "using namespace __gnu_cxx;"
        ],
        "description": "rope"
    },
    "combinatorics": {
        "prefix": "combinatorics",
        "body": [
            "const int N = 1e6 + 5, mod = 1e9 + 7;",
            "template <typename T>",
            "T inverse(T a, T MOD = mod) {",
            "    T u = 0, v = 1;",
            "    while (a != 0) {",
            "        T t = MOD / a;",
            "        MOD -= t * a;",
            "        swap(a, MOD);",
            "        u -= t * v;",
            "        swap(u, v);",
            "    }",
            "    return u;",
            "}",
            "",
            "template <const int mod = (int)1e9 + 7>",
            "struct mint {",
            "    // static int mod; // for variable mod",
            "    int64_t value;",
            "",
            "    mint(int64_t x = 0) {",
            "        value = x % mod;",
            "        if (value < 0)",
            "            value += mod;",
            "    }",
            "",
            "    mint power(int64_t p) {",
            "        mint ret = 1, base = value;",
            "        while (p) {",
            "            if (p & 1)",
            "                ret *= base;",
            "            base *= base;",
            "            p /= 2;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    friend mint operator+(mint a, mint b) { return mint(a.value + b.value); }",
            "    friend mint operator-(mint a, mint b) { return mint(a.value - b.value); }",
            "    friend mint operator*(mint a, mint b) { return mint(a.value * b.value); }",
            "    friend mint operator/(mint a, mint b) { return mint(a.value * b.power(mod - 2)); }",
            "    friend bool operator==(mint a, mint b) { return a.value == b.value; }",
            "    friend bool operator!=(mint a, mint b) { return a.value != b.value; }",
            "",
            "    mint &operator+=(mint x) { return *this = *this + x; }",
            "    mint &operator-=(mint x) { return *this = *this - x; }",
            "    mint &operator*=(mint x) { return *this = *this * x; }",
            "    mint &operator/=(mint x) { return *this = *this / x; }",
            "",
            "    friend istream &operator>>(istream &in, mint &a) { return in >> a.value, a = a.value, in; }",
            "    friend ostream &operator<<(ostream &out, mint a) { return out << a.value; }",
            "};",
            "// int mint::mod = 2; // for variable mod",
            "using Z = mint<(int)1e9 + 7>;",
            "",
            "namespace combinatorics {",
            "    vector<Z> fact = {1, 1}, fact_inv = {1, 1}, inv = {1, 1};",
            "    auto pre = []() {",
            "        fact.reserve(N + 1);",
            "        fact_inv.reserve(N + 1);",
            "        inv.reserve(N + 1);",
            "        for (int i = fact.size(); i <= N; i++) {",
            "            fact.emplace_back(fact[i - 1] * i);",
            "            inv.emplace_back(mod - mod / i * inv[mod % i]);",
            "            fact_inv.emplace_back(fact_inv[i - 1] * inv[i]);",
            "        }",
            "        return 0;",
            "    }();",
            "",
            "    Z nCr(int n, int r) {",
            "        return fact[n] * fact_inv[n - r] * fact_inv[r];",
            "    }",
            "",
            "    Z nPr(int n, int r) {",
            "        return fact[n] * fact_inv[n - r];",
            "    }",
            "",
            "    // nCr = nC(n - r)",
            "    Z stars_pars(int things, int positions) {",
            "        return nCr(positions + things - 1, things);",
            "    }",
            "",
            "    Z catalan(int n) {",
            "        return nCr(2 * n, n) * inv[n + 1];",
            "    }",
            "};",
            "using namespace combinatorics;",
            ""
        ],
        "description": "combinatorics"
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "class manacher {",
            "private:",
            "    vector<int> d;",
            "",
            "public:",
            "    manacher(string t) {",
            "        string s = \"#\";",
            "        for (auto c : t) {",
            "            s += c + string(\"#\");",
            "        }",
            "        int n = s.size(), l = 1, r = 1;",
            "        s = \"$\" + s + \"^\";",
            "        vector<int> p(n + 2);",
            "        for (int i = 1; i <= n; i++) {",
            "            p[i] = max(0, min(r - i, p[l + (r - i)]));",
            "            while (s[i - p[i]] == s[i + p[i]]) {",
            "                p[i]++;",
            "            }",
            "            if (i + p[i] > r) {",
            "                l = i - p[i], r = i + p[i];",
            "            }",
            "        }",
            "        d = vector<int>(p.begin() + 1, p.end() - 1);",
            "    }",
            "",
            "    int even(int i) {",
            "        return d[2 * i] - 1;",
            "    }",
            "",
            "    int odd(int i) {",
            "        return d[2 * i + 1] - 1;",
            "    }",
            "",
            "    bool is_palindrome(int l, int r) {",
            "        int len = r - l + 1;",
            "        if (len & 1) {",
            "            return odd((l + r) / 2) >= len;",
            "        } else {",
            "            return even((l + r) / 2 + 1) >= len;",
            "        }",
            "    }",
            "};"
        ],
        "description": "manacher"
    },
    "suffix_array": {
        "prefix": "suffix_array",
        "body": [
            "class suffix_array {",
            "private:",
            "    vector<vector<int64_t>> dp;",
            "    void build_sparse() {",
            "        if (dp.size()) {",
            "            return;",
            "        }",
            "        int n = lcp_.size(), lg = __lg(n);",
            "        dp.resize(lg + 1, vector<int64_t>(n));",
            "",
            "        for (int i = 0; i < n; ++i) {",
            "            dp[0][i] = lcp_[i];",
            "        }",
            "",
            "        for (int j = 1; j <= lg; j++) {",
            "            for (int i = 0; i + (1 << (j - 1)) < n; i++) {",
            "                dp[j][i] = min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);",
            "            }",
            "        }",
            "    }",
            "",
            "    int64_t query(int l, int r) {",
            "        int lg = 32 - __builtin_clz(r - l + 1) - 1;",
            "        return min(dp[lg][l], dp[lg][r - (1 << lg) + 1]);",
            "    }",
            "",
            "public:",
            "    vector<int> suf, group, lcp_;",
            "    suffix_array(string s) {",
            "        int n = s.size();",
            "        s += ' ';",
            "        suf = group = vector<int>(n + 1);",
            "        iota(suf.begin(), suf.end(), 0);",
            "        sort(suf.begin(), suf.end(), [&](int i, int j) {",
            "            return s[i] < s[j];",
            "        });",
            "        for (int i = 1; i <= n; ++i) {",
            "            group[suf[i]] = group[suf[i - 1]] + (s[suf[i]] != s[suf[i - 1]]);",
            "        }",
            "",
            "        vector<int> cnt, arr, ptr, newG;",
            "        int k = 1;",
            "        auto sort = [&](int x) {",
            "            cnt = arr = ptr = cnt = vector<int>(n + 1);",
            "            for (int i = 0; i <= n; ++i) {",
            "                cnt[group[(suf[i] + x) % (n + 1)]]++;",
            "            }",
            "",
            "            int sum = 0;",
            "            for (int i = 0; i <= n; ++i) {",
            "                ptr[i] = sum;",
            "                sum += cnt[i];",
            "            }",
            "",
            "            for (int i = 0; i <= n; ++i) {",
            "                arr[ptr[group[(suf[i] + x) % (n + 1)]]++] = suf[i];",
            "            }",
            "            suf = arr;",
            "        };",
            "",
            "        while (group[suf[n]] != n) {",
            "            sort(k);",
            "            sort(0);",
            "            newG = group;",
            "            for (int i = 1; i <= n; ++i) {",
            "                newG[suf[i]] = newG[suf[i - 1]] + (group[suf[i]] != group[suf[i - 1]] || group[suf[i] + k] != group[suf[i - 1] + k]);",
            "            }",
            "            group = newG;",
            "            k <<= 1;",
            "        }",
            "",
            "        k = 0;",
            "        lcp_ = vector<int>(n);",
            "        for (int i = 0; i < n; ++i) {",
            "            int pos = group[i], j = suf[pos - 1];",
            "            while (s[i + k] == s[j + k]) {",
            "                ++k;",
            "            }",
            "            lcp_[pos - 1] = k;",
            "            k = max(k - 1, 0);",
            "        }",
            "    }",
            "",
            "    int lcp(int i, int j) {",
            "        i = group[i], j = group[j];",
            "        if (i > j) {",
            "            swap(i, j);",
            "        }",
            "        if (i == j) {",
            "            return (int)lcp_.size() - suf[i];",
            "        }",
            "        if (i + 1 == j) {",
            "            return lcp_[i];",
            "        }",
            "        build_sparse();",
            "        return query(i, j - 1);",
            "    }",
            "};",
            ""
        ],
        "description": "suffix_array"
    },
    "DSU": {
        "prefix": "DSU",
        "body": [
            "class DSU {",
            "    int cnt;",
            "    vector<int> par, sz;",
            "",
            "    int find(int x) {",
            "        while (x != par[x]) {",
            "            x = par[x] = par[par[x]];",
            "        }",
            "        return x;",
            "    }",
            "",
            "public:",
            "    DSU(int n)",
            "        : cnt(n), sz(n + 1, 1), par(n + 1, 1) {",
            "        iota(par.begin(), par.end(), 0);",
            "    }",
            "",
            "    void join(int x, int y) {",
            "        x = find(x);",
            "        y = find(y);",
            "        if (x == y) {",
            "            return;",
            "        }",
            "        if (sz[x] > sz[y]) {",
            "            swap(x, y);",
            "        }",
            "        par[x] = y;",
            "        sz[y] += sz[x];",
            "        cnt--;",
            "    }",
            "",
            "    bool same(int x, int y) {",
            "        return find(x) == find(y);",
            "    }",
            "",
            "    int size(int x) {",
            "        return sz[find(x)];",
            "    }",
            "};",
            ""
        ],
        "description": "DSU"
    },
    "indexed_set": {
        "prefix": "indexed_set",
        "body": [
            "#include \"ext/pb_ds/assoc_container.hpp\"",
            "using namespace __gnu_pbds;",
            "",
            "template <class M = int, class T = less<M>>",
            "class indexed_set",
            "    : public tree<M, null_type, T, rb_tree_tag, tree_order_statistics_node_update> {",
            "private:",
            "    /*",
            "     * less<>           ---> set, increasing",
            "     * less_equal<>     ---> multiset, increasing",
            "     * greater<>        ---> set, decreasing",
            "     * greater_equal<>  ---> multiset, decreasing",
            "     */",
            "public:",
            "    void erase_element(M v) {",
            "        int rank = this->order_of_key(v);    // Number of elements that are less than v in t",
            "        auto it = this->find_by_order(rank); // Iterator that points to the (rank+1)th element in t",
            "        if (*it == v) {",
            "            this->erase(it);",
            "        }",
            "    }",
            "",
            "    void erase_all(M v) {",
            "        int cnt = count_range(v, v);",
            "        while (cnt--) {",
            "            erase_element(v);",
            "        }",
            "    }",
            "",
            "    int count_range(M l, M r) {",
            "        if (is_same<T, less<>>() || is_same<T, less<M>>()) {",
            "            auto it = this->upper_bound(r);",
            "            return (it == this->end() ? this->size() : this->order_of_key(*it)) - this->order_of_key(l);",
            "        }",
            "        if (is_same<T, less_equal<>>() || is_same<T, less_equal<M>>()) {",
            "            auto it = this->lower_bound(r);",
            "            return (it == this->end() ? this->size() : this->order_of_key(*it)) - this->order_of_key(l);",
            "        }",
            "        if (is_same<T, greater<>>() || is_same<T, greater<M>>()) {",
            "            auto it = this->upper_bound(l);",
            "            return (it == this->end() ? this->size() : this->order_of_key(*it)) - this->order_of_key(r);",
            "        }",
            "        if (is_same<T, greater_equal<>>() || is_same<T, greater_equal<M>>()) {",
            "            auto it = this->lower_bound(l);",
            "            return (it == this->end() ? this->size() : this->order_of_key(*it)) - this->order_of_key(r);",
            "        }",
            "        // for less<>, less_equal<>: return this->order_of_key(r + 1) - this->order_of_key(l);",
            "    }",
            "",
            "    M operator[](int index) {",
            "        return *this->find_by_order(index);",
            "    }",
            "",
            "    // size, insert, begin, end, rbegin, rend",
            "};",
            ""
        ],
        "description": "indexed_set"
    },
    "sqrt_deco": {
        "prefix": "sqrt_deco",
        "body": [
            "class sqrt_deco {",
            "private:",
            "    vector<int64_t> v, block;",
            "    int n, SQ;",
            "",
            "public:",
            "    sqrt_deco(const vector<int64_t> &_v) {",
            "        v = _v;",
            "        n = v.size();",
            "        SQ = (int)sqrt(n) + 1;",
            "        block.assign(SQ, 0);",
            "        for (int i = 0; i < n; ++i) {",
            "            block[i / SQ] += v[i];",
            "        }",
            "    }",
            "",
            "    void update(int i, int64_t val) {",
            "        int block_id = i / SQ;",
            "        block[block_id] -= v[i];",
            "        v[i] = val;",
            "        block[block_id] += v[i];",
            "    }",
            "",
            "    int64_t query(int l, int r) {",
            "        int64_t sum = 0;",
            "        int start = l / SQ, end = r / SQ;",
            "        if (start == end) {",
            "            for (int i = l; i <= r; i++) {",
            "                sum += v[i];",
            "            }",
            "        } else {",
            "            for (int i = l; i < (start + 1) * SQ; i++) {",
            "                sum += v[i];",
            "            }",
            "            for (int i = start + 1; i < end; i++) {",
            "                sum += block[i];",
            "            }",
            "            for (int i = end * SQ; i <= r; i++) {",
            "                sum += v[i];",
            "            }",
            "        }",
            "        return sum;",
            "    }",
            "};"
        ],
        "description": "sqrt_deco"
    },
    "sparse_segment_tree": {
        "prefix": "sparse_segment_tree",
        "body": [
            "template <class node, int64_t LX = 0, int64_t RX = (int64_t)1e18>",
            "class sparse_segment_tree {",
            "    vector<node> seg;",
            "",
            "    void create_node(int &x) {",
            "        if (x == -1) {",
            "            x = seg.size();",
            "            seg.emplace_back(node());",
            "        }",
            "    }",
            "",
            "    template <class T>",
            "    void update(int x, int64_t lx, int64_t rx, int64_t l, int64_t r, T val) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x].apply(lx, rx, val);",
            "        }",
            "        create_node(seg[x].left);",
            "        create_node(seg[x].right);",
            "        int mid = lx + rx >> 1;",
            "        seg[x].propagate(lx, rx, mid, seg[seg[x].left], seg[seg[x].right]);",
            "        int left = seg[x].left;",
            "        int right = seg[x].right;",
            "        if (l <= mid) {",
            "            update(left, lx, mid, l, r, val);",
            "        }",
            "        if (mid + 1 <= r) {",
            "            update(right, mid + 1, rx, l, r, val);",
            "        }",
            "        seg[x].merge(seg[left], seg[right]);",
            "    }",
            "",
            "    node query(int x, int64_t lx, int64_t rx, int64_t l, int64_t r) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x];",
            "        }",
            "        create_node(seg[x].left);",
            "        create_node(seg[x].right);",
            "        int mid = lx + rx >> 1;",
            "        seg[x].propagate(lx, rx, mid, seg[seg[x].left], seg[seg[x].right]);",
            "        int left = seg[x].left;",
            "        int right = seg[x].right;",
            "        if (r < mid + 1) {",
            "            return query(left, lx, mid, l, r);",
            "        }",
            "        if (mid < l) {",
            "            return query(right, mid + 1, rx, l, r);",
            "        }",
            "        node ret;",
            "        ret.merge(query(left, lx, mid, l, r), query(right, mid + 1, rx, l, r));",
            "        return ret;",
            "    }",
            "",
            "public:",
            "    sparse_segment_tree() {",
            "        seg.resize(1);",
            "    }",
            "",
            "    template <class T>",
            "    void update(int64_t l, int64_t r, T val) {",
            "        update(0, LX, RX, l, r, val);",
            "    }",
            "",
            "    node query(int64_t l, int64_t r) {",
            "        return query(0, LX, RX, l, r);",
            "    }",
            "};",
            "",
            "struct node {",
            "    int64_t sum = 0, lazy = -1;",
            "    int left = -1, right = -1;",
            "",
            "    void apply(int64_t lx, int64_t rx, int64_t val = 0) {",
            "        sum = (rx - lx + 1) * val;",
            "        lazy = val;",
            "    }",
            "",
            "    void merge(const node &a, const node &b) {",
            "        sum = a.sum + b.sum;",
            "    }",
            "",
            "    void propagate(int lx, int rx, int mid, node &left_node, node &right_node) {",
            "        if (~lazy) {",
            "            left_node.apply(lx, mid, lazy);",
            "            right_node.apply(mid + 1, rx, lazy);",
            "            lazy = -1;",
            "        }",
            "    }",
            "};",
            "",
            ""
        ],
        "description": "sparse_segment_tree"
    },
    "MO": {
        "prefix": "MO",
        "body": [
            "const int N = 2e5 + 5;",
            "class MO {",
            "    static inline int64_t hilbertOrder(int x, int y, int pow, int rotate) {",
            "        if (pow == 0) {",
            "            return 0;",
            "        }",
            "        int hpow = 1 << (pow - 1);",
            "        int seg = (x < hpow) ? ((y < hpow) ? 0 : 3) : ((y < hpow) ? 1 : 2);",
            "        seg = (seg + rotate) & 3;",
            "        const int rotateDelta[4] = {3, 0, 0, 1};",
            "        int nx = x & (x ^ hpow), ny = y & (y ^ hpow);",
            "        int nrot = (rotate + rotateDelta[seg]) & 3;",
            "        int64_t subSquareSize = int64_t(1) << (2 * pow - 2);",
            "        int64_t ans = seg * subSquareSize;",
            "        int64_t add = hilbertOrder(nx, ny, pow - 1, nrot);",
            "        ans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);",
            "        return ans;",
            "    }",
            "",
            "    struct query {",
            "        int l, r, id;",
            "        int64_t ord;",
            "    };",
            "",
            "    int q, SQ, res = 0;",
            "    vector<int> v, ans;",
            "    vector<query> queries;",
            "",
            "    int freq[N]{};",
            "",
            "    void add(int id) {",
            "    }",
            "",
            "    void remove(int id) {",
            "    }",
            "",
            "    int calc() {",
            "        return res;",
            "    }",
            "",
            "public:",
            "    MO(const vector<int> &_v, int _q) : q(_q), v(_v) {",
            "        SQ = sqrt((int)v.size()) + 1;",
            "        ans.assign(q, 0);",
            "    }",
            "",
            "    void add_query(int l, int r) {",
            "        queries.emplace_back(l, r, (int)queries.size(),",
            "                             hilbertOrder(l, r, __lg(v.size()) + 1, 0));",
            "    }",
            "",
            "    void do_work() {",
            "        sort(queries.begin(), queries.end(), [&](const auto &a, const auto &b) {",
            "            return a.ord < b.ord;",
            "        });",
            "",
            "        int l = 0, r = -1;",
            "        for (auto &[lq, rq, idx, ord] : queries) {",
            "            while (l > lq) {",
            "                add(--l);",
            "            }",
            "            while (r < rq) {",
            "                add(++r);",
            "            }",
            "            while (l < lq) {",
            "                remove(l++);",
            "            }",
            "            while (r > rq) {",
            "                remove(r--);",
            "            }",
            "            ans[idx] = calc();",
            "        }",
            "",
            "        for (auto it : ans) {",
            "            cout << it << '\\n';",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "MO"
    },
    "fenwick_tree": {
        "prefix": "fenwick_tree",
        "body": [
            "template <typename T>",
            "class fenwick_tree {",
            "    vector<T> tree;",
            "",
            "    void add(int idx, T val) {",
            "        ++idx;",
            "        while (idx < tree.size()) {",
            "            tree[idx] += val;",
            "            idx += (idx & -idx);",
            "        }",
            "    }",
            "",
            "    T get(int idx) {",
            "        ++idx;",
            "        T ret = 0;",
            "        while (idx) {",
            "            ret += tree[idx];",
            "            idx -= (idx & -idx);",
            "        }",
            "        return ret;",
            "    }",
            "",
            "public:",
            "    fenwick_tree(int n) {",
            "        tree.assign(n + 1, 0);",
            "    }",
            "",
            "    void update(int idx, T val) {",
            "        add(idx, val - query(idx, idx));",
            "    }",
            "",
            "    T query(int l, int r) {",
            "        return get(r) - get(l - 1);",
            "    }",
            "};",
            ""
        ],
        "description": "fenwick_tree"
    },
    "fenwick_tree_2D": {
        "prefix": "fenwick_tree_2D",
        "body": [
            "class fenwick_tree_2D {",
            "    int n, m;",
            "    vector<vector<int64_t>> tree;",
            "",
            "    int64_t get(int x, int y) {",
            "        ++x, ++y;",
            "        int64_t ret = 0;",
            "        for (int i = x; i; i -= i & -i) {",
            "            for (int j = y; j; j -= j & -j) {",
            "                ret += tree[i][j];",
            "            }",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    void add(int x, int y, int64_t val) {",
            "        ++x, ++y;",
            "        for (int i = x; i <= n; i += i & -i) {",
            "            for (int j = y; j <= m; j += j & -j) {",
            "                tree[i][j] += val;",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    fenwick_tree_2D(int _n, int _m) {",
            "        n = _n;",
            "        m = _m;",
            "        tree.assign(n + 5, vector<int64_t>(m + 5, 0));",
            "    }",
            "",
            "    int64_t query(int x, int y, int x2, int y2) {",
            "        return get(x2, y2) - get(x - 1, y2) - get(x2, y - 1) + get(x - 1, y - 1);",
            "    }",
            "",
            "    void update(int x, int y, int64_t val) {",
            "        add(x, y, val - query(x, y, x, y));",
            "    }",
            "};",
            ""
        ],
        "description": "fenwick_tree_2D"
    },
    "coordinate_compression": {
        "prefix": "coordinate_compression",
        "body": [
            "template <class T>",
            "vector<T> compress(vector<T> &v) {",
            "    auto real = v;",
            "    sort(real.begin(), real.end());",
            "    real.erase(unique(real.begin(), real.end()), real.end());",
            "",
            "    for (T &it : v) {",
            "        it = lower_bound(real.begin(), real.end(), it) - real.begin();",
            "    }",
            "    return real;",
            "}"
        ],
        "description": "coordinate_compression"
    },
    "LCA": {
        "prefix": "LCA",
        "body": [
            "class LCA {",
            "    int LOG;",
            "    vector<int> dep, flat, st;",
            "    vector<vector<int>> anc, dp;",
            "",
            "    int merge(int a, int b) {",
            "        if (dep[a] < dep[b]) {",
            "            return a;",
            "        }",
            "        return b;",
            "    }",
            "",
            "public:",
            "    LCA(const vector<vector<int>> &g) {",
            "        int n = (int)g.size() - 1;",
            "        LOG = __lg(n) + 1;",
            "",
            "        anc = vector(n + 1, vector(LOG + 1, 0));",
            "        st = dep = vector(n + 1, 0);",
            "",
            "        function<void(int, int)> build = [&](int u, int p) {",
            "            st[u] = flat.size();",
            "            flat.emplace_back(u);",
            "            for (auto ch : g[u]) {",
            "                if (ch == p) {",
            "                    continue;",
            "                }",
            "                dep[ch] = dep[u] + 1;",
            "                anc[ch][0] = u;",
            "                for (int bit = 1; bit < LOG; ++bit) {",
            "                    anc[ch][bit] = anc[anc[ch][bit - 1]][bit - 1];",
            "                }",
            "                build(ch, u);",
            "                flat.emplace_back(u);",
            "            }",
            "        };",
            "        build(1, 0);",
            "",
            "        int f = flat.size();",
            "        dp.assign(f, vector<int>(__lg(f) + 1));",
            "        for (int i = 0; i < f; ++i) {",
            "            dp[i][0] = flat[i];",
            "        }",
            "",
            "        for (int bit = 1; bit <= LOG; ++bit) {",
            "            for (int i = 0; i + (1 << bit) < f; ++i) {",
            "                dp[i][bit] = merge(dp[i][bit - 1],",
            "                                   dp[i + (1 << (bit - 1))][bit - 1]);",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int l, int r) {",
            "        int x = __lg(r - l + 1);",
            "        return merge(dp[l][x], dp[r - (1 << x) + 1][x]);",
            "    }",
            "",
            "    int kth_anc(int u, int k) {",
            "        for (int i = 0; i < LOG; ++i) {",
            "            if ((k >> i) & 1) {",
            "                u = anc[u][i];",
            "            }",
            "        }",
            "        return u;",
            "    }",
            "",
            "    int lca(int u, int v) {",
            "        if (st[u] > st[v]) {",
            "            swap(u, v);",
            "        }",
            "        int l = st[u], r = st[v];",
            "        return query(l, r);",
            "    }",
            "};",
            ""
        ],
        "description": "LCA"
    },
    "is_prime": {
        "prefix": "is_prime",
        "body": [
            "bool is_prime(int64_t x) {",
            "    bool y = true;",
            "    if (x == 2 || x == 3) {",
            "        y = true;",
            "    } else if (x <= 1 || x % 2 == 0 || x % 3 == 0) {",
            "        y = false;",
            "    } else {",
            "        for (int64_t i = 5; i * i <= x; i += 6) {",
            "            if (x % i == 0 || x % (i + 2) == 0) {",
            "                y = false;",
            "                break;",
            "            }",
            "        }",
            "    }",
            "    return y;",
            "}",
            ""
        ],
        "description": "is_prime"
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "using u128 = __uint128_t;",
            "using u64 = uint64_t;",
            "",
            "u64 rand(u64 l, u64 r) {",
            "    static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "    return uniform_int_distribution<u64>(l, r)(rng);",
            "}",
            "",
            "namespace primallity {",
            "    u64 mulmod(u64 a, u64 b, const u64 mod) {",
            "        return (u128)a * b % mod;",
            "    }",
            "",
            "    u64 power(u64 base, u64 e, const u64 mod) {",
            "        u64 result = 1;",
            "        base %= mod;",
            "        while (e) {",
            "            if (e & 1) {",
            "                result = mulmod(result, base, mod);",
            "            }",
            "            base = mulmod(base, base, mod);",
            "            e >>= 1;",
            "        }",
            "        return result;",
            "    }",
            "",
            "    bool check_composite(u64 n, u64 a, u64 d, int s) {",
            "        u64 x = power(a, d, n);",
            "        if (x == 1 || x == n - 1) {",
            "            return false;",
            "        }",
            "        for (int r = 1; r < s; r++) {",
            "            x = mulmod(x, x, n);",
            "            if (x == n - 1) {",
            "                return false;",
            "            }",
            "        }",
            "        return true;",
            "    };",
            "}",
            "",
            "bool is_prime(u64 n, int iter = 5) {",
            "    if (n < 4) {",
            "        return n == 2 || n == 3;",
            "    }",
            "    int s = 0;",
            "    u64 d = n - 1;",
            "    while ((d & 1) == 0) {",
            "        d >>= 1;",
            "        s++;",
            "    }",
            "    for (int i = 0; i < iter; i++) {",
            "        u64 a = rand(2, n - 2);",
            "        if (primallity::check_composite(n, a, d, s)) {",
            "            return false;",
            "        }",
            "    }",
            "    return true;",
            "}",
            ""
        ],
        "description": "miller_rabin"
    },
    "pre_inv": {
        "prefix": "pre_inv",
        "body": [
            "int inv[1000], mod = 1e9 + 7;",
            "void pre_inverse() {",
            "    inv[1] = 1;",
            "    for (int i = 2; i < 1000; ++i) {",
            "        inv[i] = mod - 1LL * (mod / i) * inv[mod % i];",
            "    }",
            "}"
        ],
        "description": "pre_inv"
    },
    "number_of_divisors": {
        "prefix": "number_of_divisors",
        "body": [
            "const int N = 1e6;",
            "vector<int> spf(N + 1), primes;",
            "void linear_sieve() {",
            "    for (int i = 2; i <= N; ++i) {",
            "        if (spf[i] == 0) {",
            "            spf[i] = i;",
            "            primes.emplace_back(i);",
            "        }",
            "        for (int j = 0; i * primes[j] <= N; ++j) {",
            "            spf[i * primes[j]] = primes[j];",
            "            if (primes[j] == spf[i]) {",
            "                break;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "int64_t number_of_divisors(int64_t n) {",
            "    int64_t ans = 1;",
            "    while (n > 1) {",
            "        int64_t num = 0, p = spf[n];",
            "        while (n % p == 0) {",
            "            n /= p, ++num;",
            "        }",
            "        ans *= (num + 1);",
            "    }",
            "    return ans;",
            "}",
            "",
            "int64_t product_of_divisors(int64_t n) {",
            "    int64_t num = number_of_divisors(n);",
            "    return power(n, num / 2) * (num & 1 ? (int64_t)sqrtl(n) : 1);",
            "}",
            "",
            "int64_t sum_of_divisors(int64_t n) {",
            "    int64_t ans = 1;",
            "    while (n > 1) {",
            "        int64_t num = 0, p = spf[n];",
            "        while (n % p == 0) {",
            "            n /= p, ++num;",
            "        }",
            "        (ans *= (power(p, num + 1) - 1) * power(p - 1, mod - 2)) %= mod;",
            "    }",
            "    return ans;",
            "}",
            ""
        ],
        "description": "number_of_divisors"
    },
    "stress_test": {
        "prefix": "stress_test",
        "body": [
            "namespace stress_test {",
            "    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "    int64_t rand(int64_t l, int64_t r) {",
            "        return uniform_int_distribution<int64_t>(l, r)(rng);",
            "    }",
            "",
            "    void shuffle(auto &x) {",
            "        shuffle(x.begin(), x.end(), rng);",
            "    }",
            "",
            "    int turn;",
            "    stringstream cin, out1, out2;",
            "    struct {",
            "        auto operator<<(const auto &x) {",
            "            if (turn == 0) {",
            "                cin << x;",
            "            }",
            "            if (turn == 1) {",
            "                out1 << x;",
            "            }",
            "            if (turn == 2) {",
            "                out2 << x;",
            "            }",
            "            if (turn == 3) {",
            "                cout << x;",
            "            }",
            "            return *this;",
            "        }",
            "    } cout;",
            "",
            "    void generate() {",
            "    }",
            "",
            "    void brute() {",
            "    }",
            "",
            "    void ac() {",
            "    }",
            "",
            "    void stress_test(int T = 1e6) {",
            "        string input;",
            "        for (int i = 1; i <= T; ++i) {",
            "            cin = stringstream(), out1 = stringstream(), out2 = stringstream();",
            "            turn = 0, generate(), input = cin.str();",
            "            turn = 1, brute(), cin = stringstream(input);",
            "            turn = 2, ac(), cin = stringstream(input);",
            "            turn = 3;",
            "            if (out1.str() != out2.str()) {",
            "                cout << \"Wrong: \" << i << \"\\n\\n\" + input + \"\\n\\nbrute:\\n\" + out1.str() + \"\\n\\nac:\\n\" + out2.str() + \"\\n\\n\";",
            "                exit(0);",
            "            }",
            "        }",
            "        cout << \"✅Accepted✅\";",
            "        exit(0);",
            "    }",
            "}"
        ],
        "description": "stress_test"
    },
    "MEX": {
        "prefix": "MEX",
        "body": [
            "class MEX {",
            "    const static int N = 1e6 + 1;",
            "    bitset<N> mex;",
            "    vector<int> freq;",
            "",
            "public:",
            "    MEX() : freq(N, 0) {",
            "        mex.set();",
            "    }",
            "",
            "    void add(int x) {",
            "        if (x >= N) {",
            "            return;",
            "        }",
            "        freq[x]++;",
            "        if (freq[x] == 1) {",
            "            mex.reset(x);",
            "        }",
            "    }",
            "",
            "    void remove(int x) {",
            "        if (x >= N) {",
            "            return;",
            "        }",
            "        freq[x]--;",
            "        if (freq[x] == 0) {",
            "            mex.set(x);",
            "        }",
            "    }",
            "",
            "    int get_mex() {",
            "        return mex._Find_first();",
            "    }",
            "};"
        ],
        "description": "MEX"
    },
    "rand": {
        "prefix": "rand",
        "body": [
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "int64_t rand(int64_t l, int64_t r) {",
            "    return uniform_int_distribution<int64_t>(l, r)(rng);",
            "}"
        ],
        "description": "rand"
    },
    "bit_freq": {
        "prefix": "bit_freq",
        "body": [
            "int64_t bit_freq(int64_t n, int b) {",
            "    int64_t res, pow = (1LL << b);",
            "    int64_t last_interval = (n / pow + 1) / 2;",
            "",
            "    res = last_interval * pow;",
            "    if (last_interval > 0) {",
            "        int64_t start = pow * (2 * (last_interval - 1) + 1), end = start + pow - 1;",
            "        if (n >= start && n <= end) {",
            "            res -= end - n;",
            "        }",
            "    }",
            "",
            "    return res;",
            "}"
        ],
        "description": "bit_freq"
    },
    "merge_seg_tree": {
        "prefix": "merge_seg_tree",
        "body": [
            "template <class node>",
            "class merge_seg_tree {",
            "private:",
            "    int size;",
            "    vector<node> seg;",
            "",
            "    template <class T>",
            "    void build(int x, int lx, int rx, const vector<T> &a) {",
            "        if (lx == rx) {",
            "            return seg[x].apply(lx, rx, a[lx]);",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        build(left, lx, mid, a);",
            "        build(right, mid + 1, rx, a);",
            "        seg[x].merge(seg[left], seg[right]);",
            "    }",
            "",
            "    vector<int> nodes;",
            "    void get(int x, int lx, int rx, int l, int r) {",
            "        if (l <= lx && rx <= r) {",
            "            return nodes.push_back(x);",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        if (l <= mid) {",
            "            get(left, lx, mid, l, r);",
            "        }",
            "        if (mid + 1 <= r) {",
            "            get(right, mid + 1, rx, l, r);",
            "        }",
            "    }",
            "",
            "public:",
            "    template <class T>",
            "    merge_seg_tree(const vector<T> &a) : size((a.size(), )), seg(2 * size) {",
            "        build(0, 0, size - 1, a);",
            "    }",
            "",
            "    int query(int l, int r, int a, int b) {",
            "        nodes.clear(), get(0, 0, size - 1, l, r);",
            "",
            "        int ret = 0;",
            "        for (auto nd : nodes) {",
            "            auto &v = seg[nd].v;",
            "            ret += upper_bound(v.begin(), v.end(), b) - lower_bound(v.begin(), v.end(), a);",
            "        }",
            "        return ret;",
            "    }",
            "};"
        ],
        "description": "merge_seg_tree"
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "template <const int mod = (int)1e9 + 7>",
            "struct mint {",
            "    // static int mod; // for variable mod",
            "    int64_t value;",
            "",
            "    mint(int64_t x = 0) {",
            "        value = x % mod;",
            "        if (value < 0)",
            "            value += mod;",
            "    }",
            "",
            "    mint power(int64_t p) {",
            "        mint ret = 1, base = value;",
            "        while (p) {",
            "            if (p & 1)",
            "                ret *= base;",
            "            base *= base;",
            "            p /= 2;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    friend mint operator+(mint a, mint b) { return mint(a.value + b.value); }",
            "    friend mint operator-(mint a, mint b) { return mint(a.value - b.value); }",
            "    friend mint operator*(mint a, mint b) { return mint(a.value * b.value); }",
            "    friend mint operator/(mint a, mint b) { return mint(a.value * b.power(mod - 2)); }",
            "    friend bool operator==(mint a, mint b) { return a.value == b.value; }",
            "    friend bool operator!=(mint a, mint b) { return a.value != b.value; }",
            "",
            "    mint &operator+=(mint x) { return *this = *this + x; }",
            "    mint &operator-=(mint x) { return *this = *this - x; }",
            "    mint &operator*=(mint x) { return *this = *this * x; }",
            "    mint &operator/=(mint x) { return *this = *this / x; }",
            "",
            "    friend istream &operator>>(istream &in, mint &a) { return in >> a.value, a = a.value, in; }",
            "    friend ostream &operator<<(ostream &out, mint a) { return out << a.value; }",
            "};",
            "// int mint::mod = 2; // for variable mod",
            "using Z = mint<(int)1e9 + 7>;"
        ],
        "description": "mint"
    },
    "diameter": {
        "prefix": "diameter",
        "body": [
            "    auto bfs = [&](int start) {",
            "        vector<int> dis(n + 1, -1);",
            "        queue<int> q;",
            "        dis[start] = 0;",
            "        q.emplace(start);",
            "        while (!q.empty()) {",
            "            int cur = q.front();",
            "            q.pop();",
            "            for (int ch : tree[cur]) {",
            "                if (dis[ch] == -1) {",
            "                    dis[ch] = dis[cur] + 1;",
            "                    q.emplace(ch);",
            "                }",
            "            }",
            "        }",
            "        return dis;",
            "    };",
            "    auto d = bfs(1);",
            "    int max_node = max_element(d.begin(), d.end()) - d.begin();",
            "    auto d_max = bfs(max_node);",
            "    int diameter = *max_element(d_max.begin(), d_max.end());"
        ],
        "description": "diameter"
    },
    "bridges": {
        "prefix": "bridges",
        "body": [
            "class bridges {",
            "    int n;",
            "    vector<int> vis, dep, low, is_bridge, is_cut_point, id;",
            "    const vector<vector<pair<int, int>>> &g;",
            "",
            "public:",
            "    bridges(vector<vector<pair<int, int>>> &_g, int m) : g(_g) {",
            "        n = g.size() - 1;",
            "        vis = dep = is_cut_point = vector(n + 1, 0);",
            "        is_bridge = vector(m, 0);",
            "        id = vector(n + 1, -1);",
            "        low = vector(n + 1, (int)1e9);",
            "        function<void(int, int)> build = [&](int v, int p) {",
            "            int children = 0;",
            "            vis[v] = 1;",
            "            for (auto &[ch, idx] : g[v]) {",
            "                if (ch == p) {",
            "                    continue;",
            "                }",
            "                if (vis[ch]) {",
            "                    low[v] = min(low[v], dep[ch]);",
            "                    continue;",
            "                }",
            "                children++;",
            "",
            "                dep[ch] = dep[v] + 1;",
            "                build(ch, v);",
            "                low[v] = min(low[v], low[ch]);",
            "                if (low[ch] > dep[v]) {",
            "                    is_bridge[idx] = 1;",
            "                }",
            "                if (low[ch] >= dep[v] && p != -1) {",
            "                    is_cut_point[v] = 1;",
            "                }",
            "            }",
            "            if (p == -1 && children > 1) {",
            "                is_cut_point[v] = 1;",
            "            }",
            "        };",
            "        build(1, -1);",
            "    }",
            "",
            "    vector<int> get_bridges() {",
            "        return is_bridge;",
            "    }",
            "",
            "    vector<int> get_cut_points() {",
            "        return is_cut_point;",
            "    }",
            "",
            "    vector<vector<int>> get_tree() {",
            "        int cur_id = 0;",
            "        function<void(int)> dfs = [&](int v) {",
            "            id[v] = cur_id + 1;",
            "            for (auto &[ch, idx] : g[v]) {",
            "                if (is_bridge[idx] || id[ch] != -1) {",
            "                    continue;",
            "                }",
            "                dfs(ch);",
            "            }",
            "        };",
            "",
            "        for (int i = 1; i <= n; ++i) {",
            "            if (id[i] != -1) {",
            "                continue;",
            "            }",
            "            dfs(i);",
            "            cur_id++;",
            "        }",
            "",
            "        vector<vector<int>> tree(cur_id + 1);",
            "        for (int v = 1; v <= n; ++v) {",
            "            for (auto &[ch, _] : g[v]) {",
            "                if (id[v] != id[ch]) {",
            "                    tree[id[v]].emplace_back(id[ch]);",
            "                }",
            "            }",
            "        }",
            "        return tree;",
            "    }",
            "};"
        ],
        "description": "bridges"
    },
    "print_vector": {
        "prefix": "print_vector",
        "body": [
            "template <class T>",
            "ostream &operator<<(ostream &os, const vector<T> &v) {",
            "    for (const auto &x : v) {",
            "        os << x << ' ';",
            "    }",
            "    cout << '\\n';",
            "    return os;",
            "}",
            "",
            "template <class T>",
            "ostream &operator<<(ostream &os, const vector<vector<T>> &v) {",
            "    for (const auto &x : v) {",
            "        for (const auto &y : x) {",
            "            os << y << ' ';",
            "        }",
            "        cout << '\\n';",
            "    }",
            "    return os;",
            "}"
        ],
        "description": "print_vector"
    },
    "SCC": {
        "prefix": "SCC",
        "body": [
            "template <int base = 1>",
            "class SCC {",
            "private:",
            "    stack<int> st;",
            "    int n, id = 1, comp_cnt;",
            "    const vector<vector<int>> &g;",
            "    vector<vector<int>> dag, comps;",
            "    vector<int> on_stack, low_link, ids, in_deg;",
            "",
            "    void dfs(int v) {",
            "        st.emplace(v), on_stack[v] = 1;",
            "        low_link[v] = ids[v] = id++;",
            "",
            "        for (auto &ch : g[v]) {",
            "            if (ids[ch] == -1) {",
            "                dfs(ch);",
            "            }",
            "            if (on_stack[ch]) {",
            "                low_link[v] = low_link[ch] = min(low_link[v], low_link[ch]);",
            "            }",
            "        }",
            "",
            "        if (ids[v] == low_link[v]) {",
            "            while (true) {",
            "                int cur = st.top();",
            "                st.pop(), on_stack[cur] = 0;",
            "                low_link[cur] = low_link[v];",
            "                if (cur == v) {",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    SCC() = default;",
            "    SCC(const vector<vector<int>> &_g) : g(_g) {",
            "        n = g.size() - 1;",
            "        ids = vector(n + 1, -1);",
            "        on_stack = low_link = vector(n + 1, 0);",
            "",
            "        for (int i = base; i <= n; ++i) {",
            "            if (ids[i] == -1) {",
            "                dfs(i);",
            "            }",
            "        }",
            "",
            "        set<int> s(low_link.begin() + base, low_link.end());",
            "        vector<int> c(s.begin(), s.end());",
            "        comp_cnt = c.size();",
            "        for (int i = base; i <= n; ++i) {",
            "            low_link[i] = lower_bound(c.begin(), c.end(), low_link[i]) - c.begin();",
            "        }",
            "    }",
            "",
            "    int components_cnt() {",
            "        return comp_cnt;",
            "    }",
            "",
            "    int component(int v) {",
            "        return low_link[v];",
            "    }",
            "",
            "    bool same_component(int u, int v) {",
            "        return component(u) == component(v);",
            "    }",
            "",
            "    vector<vector<int>> &compress() {",
            "        if (dag.empty()) {",
            "            in_deg.assign(components_cnt(), 0);",
            "            dag.resize(components_cnt());",
            "            for (int v = base; v <= n; ++v) {",
            "                for (auto &ch : g[v]) {",
            "                    if (!same_component(v, ch)) {",
            "                        dag[component(v)].emplace_back(component(ch));",
            "                        in_deg[component(ch)]++;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dag;",
            "    }",
            "",
            "    vector<vector<int>> &get_components() {",
            "        if (comps.empty()) {",
            "            comps.resize(components_cnt());",
            "            for (int i = base; i <= n; ++i) {",
            "                comps[component(i)].emplace_back(i);",
            "            }",
            "        }",
            "        return comps;",
            "    }",
            "",
            "    bool is_head(int comp) {",
            "        compress();",
            "        return !in_deg[comp];",
            "    }",
            "};",
            ""
        ],
        "description": "SCC"
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "constexpr int64_t INF = 1e18;",
            "template <int base = 1, int mode = 1> // mode = 1 (min), mode = -1 (max)",
            "class bellman_ford {",
            "private:",
            "    int n;",
            "    set<int> inf_nodes;",
            "    vector<int64_t> dis;",
            "    vector<int> par1, par2, par3;",
            "",
            "public:",
            "    bellman_ford() = default;",
            "",
            "    bellman_ford(vector<vector<pair<int, int64_t>>> &g, const vector<int> &src = {base}) {",
            "        n = (int)g.size() - 1;",
            "        dis = vector<int64_t>(n + 1, INF);",
            "        par1 = par2 = vector<int>(n + 1, -1);",
            "",
            "        for (auto it : src) {",
            "            dis[it] = 0;",
            "        }",
            "",
            "        int itr = n;",
            "        while (itr--) {",
            "            for (int i = base; i <= n; ++i) {",
            "                for (auto [next, cost] : g[i]) {",
            "                    if (dis[i] != INF && dis[i] + mode * cost < dis[next]) {",
            "                        if (itr) {",
            "                            dis[next] = dis[i] + mode * cost;",
            "                        } else {",
            "                            inf_nodes.insert(next);",
            "                        }",
            "                        par1[next] = i;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "",
            "        vector<int> q(inf_nodes.begin(), inf_nodes.end());",
            "        for (int i = 0; i < q.size(); ++i) {",
            "            if (dis[q[i]] == -INF) {",
            "                continue;",
            "            }",
            "            dis[q[i]] = -INF;",
            "",
            "            for (auto [it, c] : g[q[i]]) {",
            "                if (dis[it] != -INF) {",
            "                    par2[it] = q[i];",
            "                    q.emplace_back(it);",
            "                }",
            "            }",
            "        }",
            "",
            "        q = src;",
            "        vector<int> vis(n + 1);",
            "        par3 = vector<int>(n + 1);",
            "        for (auto it : src) {",
            "            par3[it] = -1;",
            "        }",
            "        for (int i = 0; i < q.size(); ++i) {",
            "            if (vis[q[i]]) {",
            "                continue;",
            "            }",
            "            vis[q[i]] = 1;",
            "            for (auto [it, c] : g[q[i]]) {",
            "                if (!vis[it]) {",
            "                    if (~par3[it]) {",
            "                        par3[it] = q[i];",
            "                    }",
            "                    q.emplace_back(it);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    int64_t best(int node) {",
            "        return mode * dis[node] == INF ? -1 : mode * dis[node];",
            "    }",
            "",
            "    tuple<vector<int>, int, int> get_path(int node) {",
            "        if (dis[node] == INF) {",
            "            return {};",
            "        }",
            "",
            "        vector<int> ret, vis(n + 1);",
            "        while (dis[node] == -INF && !inf_nodes.count(node)) {",
            "            ret.emplace_back(node);",
            "            node = par2[node];",
            "        }",
            "",
            "        for (int itr = n + 1; ~node && itr--; node = par1[node]) {",
            "            ret.emplace_back(node);",
            "        }",
            "",
            "        int l = (int)ret.size() - 1 - (find(ret.rbegin() + 1, ret.rend(), ret.back()) - ret.rbegin());",
            "        int r = (int)ret.size() - 1;",
            "        for (; ~node; node = par3[node]) {",
            "            ret.emplace_back(node);",
            "        }",
            "        reverse(ret.begin(), ret.end());",
            "        l = (int)ret.size() - l - 1;",
            "        r = (int)ret.size() - r - 1;",
            "        swap(l, r);",
            "        if (dis[ret.back()] != -INF) {",
            "            l = r = -1;",
            "        }",
            "        return {ret, l, r};",
            "    }",
            "};"
        ],
        "description": "bellman_ford"
    },
    "HLD": {
        "prefix": "HLD",
        "body": [
            "template <class node>",
            "class segment_tree {",
            "private:",
            "    int size;",
            "    vector<node> seg;",
            "",
            "    template <class T>",
            "    void build(int x, int lx, int rx, const vector<T> &nums) {",
            "        if (lx == rx) {",
            "            return seg[x].apply(lx, rx, nums[lx]);",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        build(left, lx, mid, nums);",
            "        build(right, mid + 1, rx, nums);",
            "        seg[x].merge(seg[left], seg[right]);",
            "    }",
            "",
            "    template <class T>",
            "    void update(int x, int lx, int rx, int l, int r, T value) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x].apply(lx, rx, value);",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        seg[x].propagate(lx, rx, seg[left], seg[right]);",
            "        if (l <= mid) {",
            "            update(left, lx, mid, l, r, value);",
            "        }",
            "        if (mid + 1 <= r) {",
            "            update(right, mid + 1, rx, l, r, value);",
            "        }",
            "        seg[x].merge(seg[left], seg[right]);",
            "    }",
            "",
            "    node query(int x, int lx, int rx, int l, int r) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x];",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        seg[x].propagate(lx, rx, seg[left], seg[right]);",
            "        if (r < mid + 1) {",
            "            return query(left, lx, mid, l, r);",
            "        }",
            "        if (mid < l) {",
            "            return query(right, mid + 1, rx, l, r);",
            "        }",
            "        node ret;",
            "        ret.merge(query(left, lx, mid, l, r), query(right, mid + 1, rx, l, r));",
            "        return ret;",
            "    }",
            "",
            "public:",
            "    template <class T>",
            "    segment_tree(int n, T val) {",
            "        size = n;",
            "        seg.resize(2 * size - 1);",
            "        build(0, 0, size - 1, vector<T>(n, val));",
            "    }",
            "",
            "    template <class T>",
            "    segment_tree(const vector<T> &nums) {",
            "        size = nums.size();",
            "        seg.resize(2 * size - 1);",
            "        build(0, 0, size - 1, nums);",
            "    }",
            "",
            "    template <class T>",
            "    void update(int l, int r, T value) {",
            "        update(0, 0, size - 1, l, r, value);",
            "    }",
            "",
            "    node query(int l, int r) {",
            "        return query(0, 0, size - 1, l, r);",
            "    }",
            "};",
            "",
            "struct node {",
            "    int64_t sum, lazy = -1;",
            "",
            "    void apply(int lx, int rx, int64_t val = 0) {",
            "        sum = (rx - lx + 1) * val;",
            "        lazy = val;",
            "    }",
            "",
            "    void merge(const node &a, const node &b) {",
            "        sum = a.sum + b.sum;",
            "    }",
            "",
            "    void propagate(int lx, int rx, node &left, node &right) {",
            "        int mid = lx + rx >> 1;",
            "        if (~lazy) {",
            "            left.apply(lx, mid, lazy);",
            "            right.apply(mid + 1, rx, lazy);",
            "            lazy = -1;",
            "        }",
            "    }",
            "};",
            "",
            "template <bool val_on_edge = false>",
            "class HLD {",
            "private:",
            "    int size;",
            "    segment_tree<node> st = segment_tree<node>(1, 0); // any DS",
            "    vector<int> par, sz, dep, heavy, id, head;",
            "",
            "public:",
            "    vector<pair<int, int>> get_path(int l, int r) {",
            "        vector<pair<int, int>> left, right;",
            "        while (head[l] != head[r]) {",
            "            if (dep[head[r]] > dep[head[l]]) {",
            "                right.emplace_back(id[head[r]], id[r]);",
            "                r = par[head[r]];",
            "            } else {",
            "                left.emplace_back(id[l], id[head[l]]);",
            "                l = par[head[l]];",
            "            }",
            "        }",
            "",
            "        if (!val_on_edge) {",
            "            left.emplace_back(id[l], id[r]);",
            "        } else if (l != r) {",
            "            left.emplace_back(id[l] > id[r] ? make_pair(id[l], id[r] + 1)",
            "                                            : make_pair(id[l] + 1, id[r]));",
            "        }",
            "        left.insert(left.end(), right.rbegin(), right.rend());",
            "        return left;",
            "    }",
            "",
            "    HLD(const vector<vector<int>> &g, int root = 1) {",
            "        size = g.size();",
            "        heavy = par = sz = dep = id = head = vector<int>(size);",
            "        st = segment_tree<node>(size, 0);",
            "        function<void(int, int)> build = [&](int u, int p) {",
            "            sz[u] = 1;",
            "            for (auto &ch : g[u]) {",
            "                if (ch == p) {",
            "                    continue;",
            "                }",
            "                dep[ch] = dep[u] + 1;",
            "                par[ch] = u;",
            "                build(ch, u);",
            "                sz[u] += sz[ch];",
            "                if (sz[ch] > sz[heavy[u]]) {",
            "                    heavy[u] = ch;",
            "                }",
            "            }",
            "            return sz[u];",
            "        };",
            "",
            "        int timer = 0;",
            "        function<void(int, int)> flatten = [&](int u, int p) {",
            "            id[u] = timer++;",
            "            if (heavy[u]) {",
            "                head[heavy[u]] = head[u];",
            "                flatten(heavy[u], u);",
            "            }",
            "",
            "            for (auto &ch : g[u]) {",
            "                if (ch == p || ch == heavy[u]) {",
            "                    continue;",
            "                }",
            "                head[ch] = ch;",
            "                flatten(ch, u);",
            "            }",
            "        };",
            "        dep[root] = 0;",
            "        build(root, -1);",
            "",
            "        head[root] = root;",
            "        flatten(root, -1);",
            "    }",
            "",
            "    template <class T>",
            "    void update_subtree(int u, const T &val) {",
            "        int L = id[u] + (val_on_edge), R = id[u] + sz[u] - 1;",
            "        if (L <= R) {",
            "            st.update(L, R, val);",
            "        }",
            "    }",
            "",
            "    template <class T>",
            "    void update_path(int u, int v, const T &val) {",
            "        for (auto [L, R] : get_path(u, v)) {",
            "            if (L > R) {",
            "                swap(L, R);",
            "            }",
            "            st.update(L, R, val);",
            "        }",
            "    }",
            "",
            "    node query_subtree(int u) {",
            "        if (val_on_edge && sz[u] == 1) {",
            "            return node();",
            "        }",
            "        return st.query(id[u] + (val_on_edge), id[u] + sz[u] - 1);",
            "    }",
            "",
            "    node query_path(int u, int v) {",
            "        auto path = get_path(u, v);",
            "        auto [l, r] = path[0];",
            "        if (l > r) {",
            "            swap(l, r);",
            "        }",
            "        node ret = st.query(l, r);",
            "        for (int i = 1; i < path.size(); ++i) {",
            "            tie(l, r) = path[i];",
            "            if (l > r) {",
            "                swap(l, r);",
            "            }",
            "            ret.merge(ret, st.query(l, r));",
            "        }",
            "        return ret;",
            "    }",
            "};",
            ""
        ],
        "description": "HLD"
    },
    "Treap": {
        "prefix": "Treap",
        "body": [
            "mt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());",
            "class Treap {",
            "private:",
            "    struct node {",
            "        int priority;",
            "        int size = 1;",
            "        node *left = nullptr, *right = nullptr;",
            "        node(int v) : priority(rng()), val(v), sum(v) {}",
            "",
            "        int val = 0;",
            "        int64_t sum = 0;",
            "        bool lazy_rev = false;",
            "        int64_t lazy_add = 0;",
            "",
            "        void apply(int v) {",
            "            val += v;",
            "            sum += size * v;",
            "            lazy_add += v;",
            "        }",
            "",
            "        void pull() {",
            "            size = 1;",
            "            sum = val;",
            "            if (left) {",
            "                size += left->size;",
            "                sum += left->sum;",
            "            }",
            "            if (right) {",
            "                size += right->size;",
            "                sum += right->sum;",
            "            }",
            "        }",
            "",
            "        void push() {",
            "            if (lazy_rev) {",
            "                swap(left, right);",
            "                if (left) {",
            "                    left->lazy_rev = !left->lazy_rev;",
            "                }",
            "                if (right) {",
            "                    right->lazy_rev = !right->lazy_rev;",
            "                }",
            "                lazy_rev = false;",
            "            }",
            "            if (lazy_add) {",
            "                if (left) {",
            "                    left->apply(lazy_add);",
            "                }",
            "                if (right) {",
            "                    right->apply(lazy_add);",
            "                }",
            "                lazy_add = 0;",
            "            }",
            "        }",
            "    };",
            "",
            "    node *root = nullptr;",
            "",
            "    int get_size(node *t) {",
            "        return t ? t->size : 0;",
            "    }",
            "",
            "    void push(node *t) {",
            "        if (t) {",
            "            t->push();",
            "        }",
            "    }",
            "",
            "    node *merge(node *left, node *right) {",
            "        if (!left) {",
            "            return right;",
            "        }",
            "        if (!right) {",
            "            return left;",
            "        }",
            "        left->push();",
            "        right->push();",
            "        if (left->priority > right->priority) {",
            "            left->right = merge(left->right, right);",
            "            push(left->left);",
            "            left->pull();",
            "            return left;",
            "        } else {",
            "            right->left = merge(left, right->left);",
            "            push(right->right);",
            "            right->pull();",
            "            return right;",
            "        }",
            "    }",
            "",
            "    void split(node *t, int k, node *&left, node *&right) {",
            "        if (!t) {",
            "            left = right = nullptr;",
            "            return;",
            "        }",
            "        push(t);",
            "        int left_size = get_size(t->left);",
            "        if (left_size >= k) {",
            "            split(t->left, k, left, t->left);",
            "            right = t;",
            "            push(right->right);",
            "            right->pull();",
            "        } else {",
            "            split(t->right, k - left_size - 1, t->right, right);",
            "            left = t;",
            "            push(left->left);",
            "            left->pull();",
            "        }",
            "    }",
            "",
            "public:",
            "    Treap() = default;",
            "",
            "    void insert(int pos, int val) {",
            "        node *new_node = new node(val);",
            "        node *left = nullptr, *right = nullptr;",
            "        split(root, pos, left, right);",
            "        root = merge(merge(left, new_node), right);",
            "    }",
            "",
            "    node *erase(int l, int r) {",
            "        if (l > r) {",
            "            return nullptr;",
            "        }",
            "        int n = get_size(root);",
            "        if (l >= n || r < 0) {",
            "            return nullptr;",
            "        }",
            "        if (l < 0) {",
            "            l = 0;",
            "        }",
            "        if (r >= n) {",
            "            r = n - 1;",
            "        }",
            "        node *left = nullptr, *mid = nullptr, *right = nullptr;",
            "        split(root, l, left, mid);",
            "        split(mid, r - l + 1, mid, right);",
            "        root = merge(left, right);",
            "        return mid;",
            "    }",
            "",
            "    void push_back(node *x) {",
            "        root = merge(root, x);",
            "    }",
            "",
            "    void reverse(int l, int r) {",
            "        node *left = nullptr, *mid = nullptr, *right = nullptr;",
            "        split(root, l, left, mid);",
            "        split(mid, r - l + 1, mid, right);",
            "        if (mid) {",
            "            mid->lazy_rev = !mid->lazy_rev;",
            "        }",
            "        root = merge(merge(left, mid), right);",
            "    }",
            "",
            "    void update(int l, int r, int64_t val) {",
            "        node *left = nullptr, *mid = nullptr, *right = nullptr;",
            "        split(root, l, left, mid);",
            "        split(mid, r - l + 1, mid, right);",
            "        if (mid) {",
            "            mid->apply(val);",
            "        }",
            "        root = merge(merge(left, mid), right);",
            "    }",
            "",
            "    int64_t query(int l, int r) {",
            "        node *left = nullptr, *mid = nullptr, *right = nullptr;",
            "        split(root, l, left, mid);",
            "        split(mid, r - l + 1, mid, right);",
            "        int64_t res = 0;",
            "        if (mid) {",
            "            res = mid->sum;",
            "        }",
            "        root = merge(merge(left, mid), right);",
            "        return res;",
            "    }",
            "",
            "    vector<int> v;",
            "    void dfs(node *root) {",
            "        if (!root) {",
            "            return;",
            "        }",
            "        push(root);",
            "        dfs(root->left);",
            "        v.push_back(root->val);",
            "        dfs(root->right);",
            "    }",
            "",
            "    vector<int> ans() {",
            "        v.clear(), dfs(root);",
            "        return v;",
            "    }",
            "};",
            ""
        ],
        "description": "Treap"
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "namespace sieve {",
            "    vector<bool> is_prime(int N) {",
            "        vector<int> _primes;",
            "        vector<bool> _is_prime(N + 1, 1);",
            "        _is_prime[0] = _is_prime[1] = 0;",
            "        for (int64_t i = 1; i <= N; i++) {",
            "            if (_is_prime[i]) {",
            "                _primes.emplace_back(i);",
            "            }",
            "            for (auto it : _primes) {",
            "                if (i * it > N) {",
            "                    break;",
            "                }",
            "                _is_prime[i * it] = 0;",
            "                if (i % it == 0) {",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "        return _is_prime;",
            "    }",
            "",
            "    vector<int> primes(int N) {",
            "        vector<int> _primes;",
            "        vector<bool> _is_prime(N + 1, 1);",
            "        _is_prime[0] = _is_prime[1] = 0;",
            "        for (int64_t i = 1; i <= N; i++) {",
            "            if (_is_prime[i]) {",
            "                _primes.emplace_back(i);",
            "            }",
            "            for (auto it : _primes) {",
            "                if (i * it > N) {",
            "                    break;",
            "                }",
            "                _is_prime[i * it] = 0;",
            "                if (i % it == 0) {",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "        return _primes;",
            "    }",
            "",
            "    vector<int> mobius(int N) {",
            "        vector<int> _primes, mob(N + 1, 1);",
            "        vector<bool> _is_prime(N + 1, 1);",
            "        _is_prime[0] = _is_prime[1] = 0;",
            "        for (int64_t i = 1; i <= N; i++) {",
            "            if (_is_prime[i]) {",
            "                mob[i] = -1;",
            "                _primes.emplace_back(i);",
            "            }",
            "            for (auto it : _primes) {",
            "                if (i * it > N) {",
            "                    break;",
            "                }",
            "                mob[i * it] = !!(i % it) * -mob[i];",
            "                _is_prime[i * it] = 0;",
            "                if (i % it == 0) {",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "        return mob;",
            "    }",
            "",
            "    vector<bool> segmented_sieve(int64_t l, int64_t r) {",
            "        vector<bool> primes_seg(r - l + 1, 1);",
            "        if (l <= 1 && 1 <= r) {",
            "            primes_seg[1 - l] = 0;",
            "        }",
            "        vector<int> prime = primes((int)sqrt(r));",
            "        for (auto it : prime) {",
            "            int64_t start = l / it * it + (l % it ? it : 0);",
            "            for (int64_t i = start; i <= r; i += it) {",
            "                if (i != it) {",
            "                    primes_seg[i - l] = 0;",
            "                }",
            "            }",
            "        }",
            "        return primes_seg;",
            "    }",
            "",
            "    vector<int> spf(int N) {",
            "        vector<int> _primes;",
            "        vector<int> _spf(N + 1, 0);",
            "        iota(_spf.begin(), _spf.end(), 0);",
            "        for (int64_t i = 2; i <= N; i++) {",
            "            if (_spf[i] == i) {",
            "                _primes.emplace_back(i);",
            "            }",
            "            for (auto it : _primes) {",
            "                if (i * it > N) {",
            "                    break;",
            "                }",
            "                _spf[i * it] = min(it, _spf[i]);",
            "                if (i % it == 0) {",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "        return _spf;",
            "    }",
            "",
            "    vector<vector<int>> factors(int N) {",
            "        auto _spf = spf(N);",
            "        vector<vector<int>> fact(N + 1);",
            "        for (int i = 1; i <= N; i++) {",
            "            int cur = i;",
            "            while (1 < cur) {",
            "                fact[i].emplace_back(_spf[cur]);",
            "                cur /= _spf[cur];",
            "            }",
            "        }",
            "        return fact;",
            "    }",
            "",
            "    vector<vector<pair<int, int>>> factors_cnt(int N) {",
            "        auto _spf = spf(N);",
            "        vector<vector<pair<int, int>>> fact(N + 1);",
            "        for (int i = 1; i <= N; i++) {",
            "            int cur = i;",
            "            vector<int> v;",
            "            while (cur > 1) {",
            "                if (v.empty() || _spf[cur] != v.back()) {",
            "                    v.emplace_back(_spf[cur]);",
            "                }",
            "                cur /= _spf[cur];",
            "            }",
            "",
            "            cur = i;",
            "            for (auto &p : v) {",
            "                int cnt = 0;",
            "                while (cur % p == 0) {",
            "                    cur /= p;",
            "                    ++cnt;",
            "                }",
            "                if (cnt) {",
            "                    fact[i].emplace_back(p, cnt);",
            "                }",
            "            }",
            "        }",
            "        return fact;",
            "    }",
            "",
            "    vector<vector<int>> divs(int N) {",
            "        vector<vector<int>> divisors(N + 1);",
            "        for (int i = 1; i <= N; i++) {",
            "            for (int j = i; j <= N; j += i) {",
            "                divisors[j].emplace_back(i);",
            "            }",
            "        }",
            "        return divisors;",
            "    }",
            "",
            "    vector<int> phi(int N) {",
            "        vector<int> _phi(N + 1);",
            "        iota(_phi.begin(), _phi.end(), 0);",
            "        for (int i = 1; i <= N; i++) {",
            "            for (int j = 2 * i; j <= N; j += i) {",
            "                _phi[j] -= _phi[i];",
            "            }",
            "        }",
            "        return _phi;",
            "    }",
            "",
            "    vector<int> next_prime(int N) {",
            "        N += 1000;",
            "        auto _is_prime = is_prime(N);",
            "        vector<int> _next_prime(N + 1, 0);",
            "        int last = 1e9 + 7;",
            "        for (int i = N; ~i; i--) {",
            "            _next_prime[i] = last;",
            "            if (_is_prime[i]) {",
            "                last = i;",
            "            }",
            "        }",
            "        return _next_prime;",
            "    }",
            "}",
            ""
        ],
        "description": ""
    },
    "tc_freq": {
        "prefix": "tc_freq",
        "body": [
            "template <class T>",
            "class tc_freq {",
            "private:",
            "    T *freq;",
            "    int *used, last = 0;",
            "    bool *used_before;",
            "",
            "public:",
            "    tc_freq(int N) {",
            "        freq = new T[N + 5]{};",
            "        used = new int[N + 5]{};",
            "        used_before = new bool[N + 5]{};",
            "    }",
            "",
            "    void reset() {",
            "        while (last) {",
            "            last--;",
            "            used_before[used[last]] = 0;",
            "            freq[used[last]] = 0;",
            "        }",
            "    }",
            "",
            "    T &operator[](int index) {",
            "        if (!used_before[index]) {",
            "            used_before[index] = 1;",
            "            used[last++] = index;",
            "        }",
            "        return freq[index];",
            "    }",
            "};"
        ],
        "description": "tc_freq"
    },
    "dynamic_dr_string": {
        "prefix": "dynamic_dr_string",
        "body": [
            "template <class node>",
            "class segment_tree {",
            "private:",
            "    int size;",
            "    vector<node> seg;",
            "",
            "    template <class T>",
            "    void build(int x, int lx, int rx, const vector<T> &nums) {",
            "        if (lx == rx) {",
            "            return seg[x].apply(lx, rx, nums[lx]);",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        build(left, lx, mid, nums);",
            "        build(right, mid + 1, rx, nums);",
            "        seg[x].merge(seg[left], seg[right]);",
            "    }",
            "",
            "    template <class T>",
            "    void update(int x, int lx, int rx, int l, int r, T value) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x].apply(lx, rx, value);",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        seg[x].propagate(lx, rx, seg[left], seg[right]);",
            "        if (l <= mid) {",
            "            update(left, lx, mid, l, r, value);",
            "        }",
            "        if (mid + 1 <= r) {",
            "            update(right, mid + 1, rx, l, r, value);",
            "        }",
            "        seg[x].merge(seg[left], seg[right]);",
            "    }",
            "",
            "    node query(int x, int lx, int rx, int l, int r) {",
            "        if (l <= lx && rx <= r) {",
            "            return seg[x];",
            "        }",
            "        int mid = lx + rx >> 1;",
            "        int left = x + 1;",
            "        int right = x + 2 * (mid - lx + 1);",
            "        seg[x].propagate(lx, rx, seg[left], seg[right]);",
            "        if (r < mid + 1) {",
            "            return query(left, lx, mid, l, r);",
            "        }",
            "        if (mid < l) {",
            "            return query(right, mid + 1, rx, l, r);",
            "        }",
            "        node ret;",
            "        ret.merge(query(left, lx, mid, l, r), query(right, mid + 1, rx, l, r));",
            "        return ret;",
            "    }",
            "",
            "public:",
            "    template <class T>",
            "    segment_tree(int n, T val) {",
            "        size = n;",
            "        seg.resize(2 * size - 1);",
            "        build(0, 0, size - 1, vector<T>(n, val));",
            "    }",
            "",
            "    template <class T>",
            "    segment_tree(const vector<T> &nums) {",
            "        size = nums.size();",
            "        seg.resize(2 * size - 1);",
            "        build(0, 0, size - 1, nums);",
            "    }",
            "",
            "    template <class T>",
            "    void update(int l, int r, T value) {",
            "        update(0, 0, size - 1, l, r, value);",
            "    }",
            "",
            "    node query(int l, int r) {",
            "        return query(0, 0, size - 1, l, r);",
            "    }",
            "};",
            "",
            "class dr_string {",
            "private:",
            "    using i128 = __int128_t;",
            "    static const int64_t mod = (1LL << 61) - 1;",
            "    static int64_t base;",
            "    static vector<int64_t> pow, pow_sum;",
            "",
            "    struct node {",
            "        int len, lazy = -1;",
            "        int64_t hash, hash_rev;",
            "",
            "        void apply(int lx, int rx, int64_t val = 0) {",
            "            lazy = val;",
            "            len = rx - lx + 1;",
            "            hash = hash_rev = val * (i128)pow_sum[len] % mod;",
            "        }",
            "",
            "        void merge(const node &a, const node &b) {",
            "            len = a.len + b.len;",
            "            hash = (a.hash + (i128)b.hash * pow[a.len]) % mod;",
            "            hash_rev = (b.hash_rev + (i128)a.hash_rev * pow[b.len]) % mod;",
            "        }",
            "",
            "        void propagate(int lx, int rx, node &left, node &right) {",
            "            int mid = lx + rx >> 1;",
            "            if (~lazy) {",
            "                left.apply(lx, mid, lazy);",
            "                right.apply(mid + 1, rx, lazy);",
            "                lazy = -1;",
            "            }",
            "        }",
            "    };",
            "",
            "    segment_tree<node> st = segment_tree<node>(1, 0);",
            "",
            "public:",
            "    dr_string(const auto &s) {",
            "        while (pow.size() <= s.size()) {",
            "            pow_sum.emplace_back((pow_sum.back() + pow.back()) % mod);",
            "            pow.emplace_back((i128)pow.back() * base % mod);",
            "        }",
            "        st = segment_tree<node>(vector<int64_t>(s.begin(), s.end()));",
            "    }",
            "",
            "    void update(int l, int r, char val) {",
            "        st.update(l, r, val);",
            "    }",
            "",
            "    int64_t substr(int l, int r) {",
            "        return st.query(l, r).hash;",
            "    }",
            "",
            "    int64_t substr_rev(int l, int r) {",
            "        return st.query(l, r).hash_rev;",
            "    }",
            "",
            "    bool is_palindrome(int l, int r) {",
            "        return substr(l, r) == substr_rev(l, r);",
            "    }",
            "};",
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "int64_t dr_string::base = (mod >> 2) + rng() % (mod >> 1);",
            "vector<int64_t> dr_string::pow = {1}, dr_string::pow_sum = {0};",
            ""
        ],
        "description": "dynamic_dr_string"
    },
    "edge": {
        "prefix": "edge",
        "body": [
            "struct edge {",
            "    int u, v;",
            "    int64_t w;",
            "    edge() {}",
            "    edge(int _u, int _v, int64_t w) : u(_u), v(_v), w(w) {}",
            "",
            "    bool operator<(const edge &e) const {",
            "        return w < e.w;",
            "    }",
            "};",
            ""
        ],
        "description": "edge"
    },
    "TwoSat": {
        "prefix": "TwoSat",
        "body": [
            "/*",
            "    add logical statements using n variables:",
            "",
            "    Assert(f_a, a)      ====> (f_a ? a : !a) = true;",
            "    Or(f_a, a, f_b, b)  ====> (f_a ? a : !a) or (f_b ? b : !b) = true;",
            "    And(f_a, a, f_b, b) ====> (f_a ? a : !a) and (f_b ? b : !b) = true;",
            "    etc...",
            "",
            "    get answer that satisfies all logical statements.",
            "*/",
            "class TwoSat {",
            "private:",
            "    int n;",
            "    vector<vector<int>> e;",
            "    vector<bool> ans;",
            "    void addClause(int u, bool f, int v, bool g) {",
            "        e[2 * u + !f].emplace_back(2 * v + g);",
            "        e[2 * v + !g].emplace_back(2 * u + f);",
            "    }",
            "",
            "public:",
            "    TwoSat(int n) : n(n), e(2 * n), ans(n) {}",
            "    bool satisfiable() {",
            "        vector<int> id(2 * n, -1), dfn(2 * n, -1), low(2 * n, -1);",
            "        vector<int> stk;",
            "        int now = 0, cnt = 0;",
            "        function<void(int)> tarjan = [&](int u) {",
            "            stk.emplace_back(u);",
            "            dfn[u] = low[u] = now++;",
            "            for (auto v : e[u]) {",
            "                if (dfn[v] == -1) {",
            "                    tarjan(v);",
            "                    low[u] = min(low[u], low[v]);",
            "                } else if (id[v] == -1) {",
            "                    low[u] = min(low[u], dfn[v]);",
            "                }",
            "            }",
            "            if (dfn[u] == low[u]) {",
            "                int v;",
            "                do {",
            "                    v = stk.back();",
            "                    stk.pop_back();",
            "                    id[v] = cnt;",
            "                } while (v != u);",
            "                ++cnt;",
            "            }",
            "        };",
            "        for (int i = 0; i < 2 * n; ++i) {",
            "            if (dfn[i] == -1) {",
            "                tarjan(i);",
            "            }",
            "        }",
            "        for (int i = 0; i < n; ++i) {",
            "            if (id[2 * i] == id[2 * i + 1]) {",
            "                return false;",
            "            }",
            "            ans[i] = id[2 * i] > id[2 * i + 1];",
            "        }",
            "        return true;",
            "    }",
            "    vector<bool> answer() { return ans; }",
            "",
            "    void Or(bool f_a, int a, bool f_b, int b) {",
            "        addClause(a, f_a, b, f_b);",
            "    }",
            "",
            "    void Assert(bool f_a, int a) {",
            "        Or(f_a, a, f_a, a);",
            "    }",
            "",
            "    void And(bool f_a, int a, bool f_b, int b) {",
            "        Assert(f_a, a);",
            "        Assert(f_b, b);",
            "    }",
            "",
            "    void Xor(bool f_a, int a, bool f_b, int b) {",
            "        Or(f_a, a, f_b, b);",
            "        Or(!f_a, a, !f_b, b);",
            "    }",
            "",
            "    void Nor(bool f_a, int a, bool f_b, int b) {",
            "        And(!f_a, a, !f_b, b);",
            "    }",
            "",
            "    void Nand(bool f_a, int a, bool f_b, int b) {",
            "        Or(!f_a, a, !f_b, b);",
            "    }",
            "",
            "    void Xnor(bool f_a, int a, bool f_b, int b) {",
            "        Or(!f_a, a, f_b, b);",
            "        Or(f_a, a, !f_b, b);",
            "    }",
            "};",
            ""
        ],
        "description": "TwoSat"
    },
    "small_to_large": {
        "prefix": "small_to_large",
        "body": [
            "class small_to_large {",
            "private:",
            "    vector<vector<int>> &g;",
            "    vector<int> tree, in, sz, &v, ans;",
            "",
            "    void euler(int node, int p) {",
            "        in[node] = tree.size();",
            "        tree.emplace_back(node);",
            "        sz[node] = 1;",
            "        for (auto ch : g[node]) {",
            "            if (ch == p) {",
            "                continue;",
            "            }",
            "            euler(ch, node);",
            "            sz[node] += sz[ch];",
            "        }",
            "    }",
            "",
            "    void dfs(int node, int p, bool keep) {",
            "        int heavy = -1;",
            "        for (auto ch : g[node]) {",
            "            if (ch != p && (heavy == -1 || sz[ch] > sz[heavy])) {",
            "                heavy = ch;",
            "            }",
            "        }",
            "        for (auto ch : g[node]) {",
            "            if (ch != p && ch != heavy) {",
            "                dfs(ch, node, false);",
            "            }",
            "        }",
            "        if (~heavy) {",
            "            dfs(heavy, node, true);",
            "        }",
            "",
            "        add(node);",
            "        for (auto ch : g[node]) {",
            "            if (ch != p && ch != heavy) {",
            "                for (int i = 0; i < sz[ch]; ++i) {",
            "                    add(tree[in[ch] + i]);",
            "                }",
            "            }",
            "        }",
            "        calc(node);",
            "        if (!keep) {",
            "            for (int i = 0; i < sz[node]; ++i) {",
            "                remove(tree[in[node] + i]);",
            "            }",
            "        }",
            "    }",
            "",
            "    int res = 0;",
            "    void add(int node) {",
            "    }",
            "",
            "    void remove(int node) {",
            "    }",
            "",
            "    // you have only the nodes down, the node itself is not included",
            "    void calc(int node) {",
            "        ans[node] = res;",
            "    }",
            "",
            "public:",
            "    small_to_large(vector<vector<int>> &g, vector<int> &v) : g(g), v(v) {",
            "        in = sz = ans = vector<int>(g.size());",
            "        euler(1, -1), dfs(1, -1, false);",
            "    }",
            "",
            "    vector<int> get() { return ans; }",
            "};",
            ""
        ],
        "description": "small_to_large"
    },
    "LCA_weighted": {
        "prefix": "LCA_weighted",
        "body": [
            "const int64_t inf = 1e18;",
            "template <class T = pair<int64_t, int64_t>>",
            "class LCA_weighted {",
            "",
            "    int n, LOG;",
            "    vector<int> dep, par;",
            "    vector<vector<int>> anc;",
            "    vector<vector<T>> cost;",
            "    vector<vector<pair<int, int64_t>>> &g;",
            "",
            "    T merge(const T &a, const T &b) {",
            "        return pair{min(a.first, b.first), max(a.second, b.second)};",
            "    }",
            "",
            "    T get_cost(int u, int k) {",
            "        T res = {inf, -inf};",
            "        for (int bit = 0; bit < LOG; ++bit) {",
            "            if ((k >> bit) & 1) {",
            "                res = merge(res, cost[u][bit]);",
            "                u = anc[u][bit];",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "public:",
            "    LCA_weighted(int _n, vector<vector<pair<int, int64_t>>> &_g)",
            "        : n(_n), g(_g), LOG(__lg(n) + 1) {",
            "        anc = vector(n + 1, vector(LOG + 1, 0));",
            "        cost = vector(n + 1, vector<T>(LOG + 1, pair{inf, -inf}));",
            "        dep = par = vector(n + 1, 0);",
            "",
            "        function<void(int, int)> build = [&](int u, int p) {",
            "            for (const auto &[ch, w] : g[u]) {",
            "                if (ch == p) {",
            "                    continue;",
            "                }",
            "                dep[ch] = dep[u] + 1;",
            "                par[ch] = anc[ch][0] = u;",
            "                cost[ch][0] = {w, w};",
            "                for (int bit = 1; bit < LOG; ++bit) {",
            "                    anc[ch][bit] = anc[anc[ch][bit - 1]][bit - 1];",
            "                    cost[ch][bit] = merge(cost[anc[ch][bit - 1]][bit - 1], cost[ch][bit - 1]);",
            "                }",
            "                build(ch, u);",
            "            }",
            "        };",
            "        build(1, 0);",
            "    }",
            "",
            "    int kth_anc(int u, int k) {",
            "        for (int i = 0; i < LOG; ++i) {",
            "            if ((k >> i) & 1) {",
            "                u = anc[u][i];",
            "            }",
            "        }",
            "        return u;",
            "    }",
            "",
            "    int lca(int u, int v) {",
            "        if (dep[u] < dep[v]) {",
            "            swap(u, v);",
            "        }",
            "        u = kth_anc(u, dep[u] - dep[v]);",
            "        if (u == v) {",
            "            return u;",
            "        }",
            "",
            "        for (int bit = LOG - 1; ~bit; --bit) {",
            "            if (anc[u][bit] != anc[v][bit]) {",
            "                u = anc[u][bit];",
            "                v = anc[v][bit];",
            "            }",
            "        }",
            "        return anc[u][0];",
            "    }",
            "",
            "    T query(int u, int v) {",
            "        auto lc = lca(u, v);",
            "        return merge(get_cost(u, dep[u] - dep[lc]), get_cost(v, dep[v] - dep[lc]));",
            "    }",
            "};",
            ""
        ],
        "description": "LCA_weighted"
    },
    "permutation_power": {
        "prefix": "permutation_power",
        "body": [
            "vector<int> permutation_power(vector<int> p, int64_t k) {",
            "    vector<int> s = p;",
            "    while (k) {",
            "        if (k % 2 == 1) {",
            "            auto tmp = s;",
            "            for (int i = 0; i < p.size(); ++i) {",
            "                s[i] = tmp[p[i] - 1];",
            "            }",
            "        }",
            "        auto tmp = p;",
            "        for (int i = 0; i < p.size(); ++i) {",
            "            p[i] = tmp[tmp[i] - 1];",
            "        }",
            "        k /= 2;",
            "    }",
            "    return s;",
            "}"
        ],
        "description": "permutation_power"
    },
    "generate_divisors": {
        "prefix": "generate_divisors",
        "body": [
            "const int N = 1e6 + 5;",
            "vector<int> calc(int N) {",
            "    vector<int> _primes, _spf(N + 1, 0);",
            "    iota(_spf.begin(), _spf.end(), 0);",
            "    for (long long i = 2; i <= N; i++) {",
            "        if (_spf[i] == i) {",
            "            _primes.push_back(i);",
            "        }",
            "        for (auto it : _primes) {",
            "            if (i * it > N) {",
            "                break;",
            "            }",
            "            _spf[i * it] = min(it, _spf[i]);",
            "            if (i % it == 0) {",
            "                break;",
            "            }",
            "        }",
            "    }",
            "    return _spf;",
            "}",
            "",
            "vector<int> spf = calc(N);",
            "vector<int> factors(int n) {",
            "    vector<int> ret;",
            "    int cur = n;",
            "    while (cur > 1) {",
            "        ret.push_back(spf[cur]);",
            "        cur /= spf[cur];",
            "    }",
            "    return ret;",
            "}",
            "",
            "vector<int> divisors(int n) {",
            "    auto fact = factors(n);",
            "    vector<array<int, 2>> p;",
            "    for (auto &it : fact) {",
            "        if (p.empty() || p.back()[0] != it) {",
            "            p.push_back({it, 1});",
            "        } else {",
            "            p.back()[1]++;",
            "        }",
            "    }",
            "    vector<int> ret;",
            "    function<void(int, int)> build = [&](int i, int res) {",
            "        if (i == p.size()) {",
            "            ret.push_back(res);",
            "            return;",
            "        }",
            "        int x = 1, itr = p[i][1] + 1;",
            "        while (itr--) {",
            "            build(i + 1, res * x);",
            "            x *= p[i][0];",
            "        }",
            "    };",
            "    build(0, 1);",
            "    sort(ret.begin(), ret.end());",
            "    return ret;",
            "}"
        ],
        "description": "generate_divisors"
    },
    "benchamark": {
        "prefix": "benchamark",
        "body": [
            "    auto t = clock();",
            "    cerr << \"Time: \" << (clock() - t) * 1000 / CLOCKS_PER_SEC << \" ms\\n\";",
            ""
        ],
        "description": "benchamark"
    },
    "hash_map": {
        "prefix": "hash_map",
        "body": [
            "struct HASH {",
            "    int64_t operator()(int64_t x) const {",
            "        x ^= (x >> 30), x *= UINT64_C(0xbf58476d1ce4e5b9);",
            "        x ^= (x >> 27), x *= UINT64_C(0x94d049bb133111eb);",
            "        return x ^ (x >> 31);",
            "    }",
            "};",
            "",
            "template <typename k, typename v>",
            "struct hash_map {",
            "    unordered_map<k, v, HASH> m;",
            "    k toXor;",
            "    hash_map() {",
            "        toXor = chrono::steady_clock::now().time_since_epoch().count();",
            "        m.reserve(4096);",
            "        m.max_load_factor(0.25);",
            "    }",
            "    v &operator[](const k &key) { return m[key ^ toXor]; }",
            "    auto find(const k &key) { return m.find(key ^ toXor); }",
            "    auto end() { return m.end(); }",
            "};",
            ""
        ],
        "description": "hash_map"
    },
    "discrete_log": {
        "prefix": "discrete_log",
        "body": [
            "/*",
            "a^x = b (mod m)",
            "",
            "x = np - q",
            "n = sqrt(m)",
            "p = [1, n]",
            "q = [0, n]",
            "",
            "a^(n * p) = b * a^q (mod m)",
            "*/",
            "int64_t discrete_log(int64_t a, int64_t b, int64_t m) {",
            "    a %= m, b %= m;",
            "",
            "    // if 0^0 is undefined",
            "    if (a == 0) {",
            "        return b == 0 ? 1 : -1;",
            "    }",
            "",
            "    int64_t k = 1, add = 0, g;",
            "    while ((g = gcd(a, m)) > 1) {",
            "        if (b == k) {",
            "            return add;",
            "        }",
            "        if (b % g) {",
            "            return -1;",
            "        }",
            "        b /= g, m /= g, ++add;",
            "        k = (__int128_t)k * (a / g) % m;",
            "    }",
            "",
            "    int64_t n = sqrtl(m) + 1;",
            "    int64_t an = 1; // a^n",
            "    for (int i = 0; i < n; ++i) {",
            "        an = (__int128_t)an * a % m;",
            "    }",
            "",
            "    unordered_map<int64_t, int64_t> rhs;",
            "    for (int64_t q = 0, cur = b; q <= n; ++q) {",
            "        rhs[cur] = q;",
            "        cur = (__int128_t)cur * a % m;",
            "    }",
            "",
            "    int64_t ans = -1;",
            "    for (int64_t p = 1, cur = k; p <= n; ++p) {",
            "        cur = (__int128_t)cur * an % m; // a^(n * p)",
            "        if (rhs.count(cur)) {",
            "            ans = n * p - rhs[cur] + add; // x = np - q",
            "            break;",
            "        }",
            "    }",
            "    return ans;",
            "}",
            ""
        ],
        "description": "discrete_log"
    },
    "ronaldo": {
        "prefix": "ronaldo",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "auto go = []() {",
            "    ios_base::sync_with_stdio(false), cin.tie(nullptr);",
            "#ifndef ONLINE_JUDGE",
            "    freopen(\"in.txt\", \"r\", stdin);",
            "    freopen(\"out.txt\", \"w\", stdout);",
            "#endif",
            "    return 0;",
            "}();",
            "",
            "void solve() {",
            "    ${0}",
            "}",
            "",
            "signed main() {",
            "    int T = 1;",
            "    // cin >> T;",
            "    for (int tt = 1; tt <= T; ++tt) {",
            "        solve();",
            "        if (tt < T) {",
            "            cout << '\\n';",
            "        }",
            "    }",
            "}"
        ],
        "description": "ronaldo"
    },
    "primitive_root": {
        "prefix": "primitive_root",
        "body": [
            "int64_t power(int64_t a, int64_t b, const int MOD) {",
            "    a %= MOD;",
            "    int64_t s = 1;",
            "    while (b) {",
            "        if (b % 2 == 1)",
            "            s = s * a % MOD;",
            "        a = a * a % MOD;",
            "        b /= 2;",
            "    }",
            "    return s;",
            "}",
            "",
            "// p * log(p) ^ 6",
            "int primitive_root(int p) {",
            "    if (!is_prime(p)) {",
            "        return -1;",
            "    }",
            "    vector<int> fact;",
            "    int phi = p - 1, n = phi;",
            "    for (int i = 2; i <= n / i; ++i) {",
            "        if (n % i == 0) {",
            "            fact.emplace_back(i);",
            "            while (n % i == 0) {",
            "                n /= i;",
            "            }",
            "        }",
            "    }",
            "    if (n > 1) {",
            "        fact.emplace_back(n);",
            "    }",
            "",
            "    for (int res = 2; res <= p; ++res) {",
            "        bool ok = true;",
            "        for (size_t i = 0; i < fact.size() && ok; ++i) {",
            "            ok &= power(res, phi / fact[i], p) != 1;",
            "        }",
            "        if (ok) {",
            "            return res;",
            "        }",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "primitive_root"
    },
    "FFT": {
        "prefix": "FFT",
        "body": [
            "using cd = complex<double>;",
            "const double PI = acos(-1);",
            "class FFT {",
            "    static int reverse(int num, int lg_n) {",
            "        int res = 0;",
            "        for (int i = 0; i < lg_n; i++) {",
            "            if (num & (1 << i)) {",
            "                res |= 1 << (lg_n - 1 - i);",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    static void fft(vector<cd> &a, bool invert) {",
            "        int n = a.size(), lg_n = 0;",
            "        while ((1 << lg_n) < n) {",
            "            lg_n++;",
            "        }",
            "        for (int i = 0; i < n; i++) {",
            "            int rev = reverse(i, lg_n);",
            "            if (i < rev) {",
            "                swap(a[i], a[rev]);",
            "            }",
            "        }",
            "",
            "        for (int len = 2; len <= n; len <<= 1) {",
            "            double ang = 2 * PI / len * (invert ? -1 : 1);",
            "            cd wlen(cos(ang), sin(ang));",
            "            for (int i = 0; i < n; i += len) {",
            "                cd w(1);",
            "                for (int j = 0; j < len / 2; j++) {",
            "                    cd u = a[i + j], v = a[i + j + len / 2] * w;",
            "                    a[i + j] = u + v;",
            "                    a[i + j + len / 2] = u - v;",
            "                    w *= wlen;",
            "                }",
            "            }",
            "        }",
            "",
            "        if (invert) {",
            "            for (cd &x : a) {",
            "                x /= n;",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    template <class T>",
            "    static vector<T> mul(vector<T> const &a, vector<T> const &b) {",
            "        vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());",
            "        int n = 1;",
            "        while (n < a.size() + b.size()) {",
            "            n <<= 1;",
            "        }",
            "        fa.resize(n), fb.resize(n);",
            "        fft(fa, false), fft(fb, false);",
            "",
            "        for (int i = 0; i < n; i++) {",
            "            fa[i] *= fb[i];",
            "        }",
            "        fft(fa, true);",
            "",
            "        vector<T> res(n);",
            "        for (int i = 0; i < n; i++) {",
            "            res[i] = round(fa[i].real());",
            "        }",
            "        return res;",
            "    }",
            "",
            "    template <class T>",
            "    static vector<T> poly_pow(vector<T> poly, int p) {",
            "        vector<T> ans{1};",
            "        while (p) {",
            "            if (p & 1) {",
            "                ans = mul(ans, poly);",
            "            }",
            "            poly = mul(poly, poly);",
            "            p >>= 1;",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    static string mul_big_int(const string &s1, const string &s2) {",
            "        int n = s1.size(), m = s2.size();",
            "        vector<int> p1(n), p2(m);",
            "        for (int i = 0; i < n; ++i) {",
            "            p1[n - i - 1] = s1[i] - '0';",
            "        }",
            "        for (int i = 0; i < m; ++i) {",
            "            p2[m - i - 1] = s2[i] - '0';",
            "        }",
            "",
            "        vector<int> ans = mul(p1, p2);",
            "        int k = ans.size();",
            "        for (int i = 0; i < k - 1; ++i) {",
            "            ans[i + 1] += ans[i] / 10;",
            "            ans[i] = ans[i] % 10;",
            "        }",
            "",
            "        string final = to_string(ans[k - 1]);",
            "        for (int i = k - 2; i >= 0; --i) {",
            "            final += (char)(ans[i] + '0');",
            "        }",
            "",
            "        for (int i = 0; i < k; ++i) {",
            "            if (final[i] != '0') {",
            "                return final.substr(i);",
            "            }",
            "        }",
            "        return \"0\";",
            "    }",
            "",
            "    static string big_int_pow(string s, int p) {",
            "        string ans = \"1\";",
            "        while (p) {",
            "            if (p & 1) {",
            "                ans = mul_big_int(ans, s);",
            "            }",
            "            s = mul_big_int(s, s);",
            "            p >>= 1;",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    static vector<int> str_match(const string &s, const string &patt) {",
            "        int n = s.size(), m = patt.size();",
            "        vector<int> p1(n), p2(m), ans_match(n);",
            "        int shift = m - 1;",
            "        for (int i = 0; i < 26; ++i) {",
            "            for (int j = 0; j < n; ++j) {",
            "                p1[j] = (s[j] - 'a') == i;",
            "            }",
            "            for (int j = 0; j < m; ++j) {",
            "                p2[j] = (patt[-j + shift] - 'a') == i;",
            "            }",
            "",
            "            vector<int> ans = mul(p1, p2);",
            "            for (int j = 0; j < n; ++j) {",
            "                ans_match[j] += ans[j + shift];",
            "            }",
            "        }",
            "        return ans_match;",
            "    }",
            "",
            "    static vector<int> wild_card_cnt(const string &s, const string &patt) {",
            "        int n = s.size(), m = patt.size();",
            "        vector<int> ans_match = str_match(s, patt), pos;",
            "        int wild_cnt = count(patt.begin(), patt.end(), '*');",
            "        for (int i = 0; i < n; ++i) {",
            "            if (ans_match[i] == m - wild_cnt) {",
            "                pos.push_back(i);",
            "            }",
            "        }",
            "        return pos;",
            "    }",
            "};"
        ],
        "description": "FFT"
    },
    "NTT": {
        "prefix": "NTT",
        "body": [
            "template <const int mod = 998244353>",
            "struct mint {",
            "    // static int mod; // for variable mod",
            "    int64_t value;",
            "",
            "    mint(int64_t x = 0) {",
            "        value = x % mod;",
            "        if (value < 0)",
            "            value += mod;",
            "    }",
            "",
            "    mint power(int64_t p) {",
            "        mint ret = 1, base = value;",
            "        while (p) {",
            "            if (p & 1)",
            "                ret *= base;",
            "            base *= base;",
            "            p /= 2;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    friend mint operator+(mint a, mint b) { return mint(a.value + b.value); }",
            "    friend mint operator-(mint a, mint b) { return mint(a.value - b.value); }",
            "    friend mint operator*(mint a, mint b) { return mint(a.value * b.value); }",
            "    friend mint operator/(mint a, mint b) { return mint(a.value * b.power(mod - 2)); }",
            "    friend bool operator==(mint a, mint b) { return a.value == b.value; }",
            "    friend bool operator!=(mint a, mint b) { return a.value != b.value; }",
            "",
            "    mint &operator+=(mint x) { return *this = *this + x; }",
            "    mint &operator-=(mint x) { return *this = *this - x; }",
            "    mint &operator*=(mint x) { return *this = *this * x; }",
            "    mint &operator/=(mint x) { return *this = *this / x; }",
            "",
            "    friend istream &operator>>(istream &in, mint &a) { return in >> a.value, a = a.value, in; }",
            "    friend ostream &operator<<(ostream &out, mint a) { return out << a.value; }",
            "};",
            "// int mint::mod = 2; // for variable mod",
            "using Z = mint<998244353>;",
            "",
            "class NTT {",
            "    template <int mod, int primitive_root>",
            "    static void ntt(vector<int> &A, bool invert) {",
            "        using Z = mint<mod>;",
            "        vector<Z> a(A.begin(), A.end());",
            "        int n = a.size();",
            "        for (int i = 1, j = 0; i < n; i++) {",
            "            int bit = n >> 1;",
            "            for (; j & bit; bit >>= 1) {",
            "                j ^= bit;",
            "            }",
            "            j ^= bit;",
            "            if (i < j) {",
            "                swap(a[i], a[j]);",
            "            }",
            "        }",
            "",
            "        for (int len = 2; len <= n; len <<= 1) {",
            "            Z wlen = Z(primitive_root).power((mod - 1) / len);",
            "            if (invert)",
            "                wlen = 1 / wlen;",
            "            for (int i = 0; i < n; i += len) {",
            "                Z w = 1;",
            "                for (int j = 0; j < len / 2; j++) {",
            "                    Z u = a[i + j], v = a[i + j + len / 2] * w;",
            "                    a[i + j] = u + v;",
            "                    a[i + j + len / 2] = u - v;",
            "                    w *= wlen;",
            "                }",
            "            }",
            "        }",
            "        if (invert) {",
            "            Z inv_n = 1 / (Z)n;",
            "            for (auto &x : a) {",
            "                x *= inv_n;",
            "            }",
            "        }",
            "        for (int i = 0; i < n; ++i) {",
            "            A[i] = a[i].value;",
            "        }",
            "    }",
            "",
            "    template <int mod, int primitive_root>",
            "    static vector<int> multiply(vector<int> a, vector<int> b) {",
            "        int n = 1;",
            "        while (n < int(a.size() + b.size())) {",
            "            n <<= 1;",
            "        }",
            "        a.resize(n), b.resize(n);",
            "        ntt<mod, primitive_root>(a, false);",
            "        ntt<mod, primitive_root>(b, false);",
            "        for (int i = 0; i < n; i++) {",
            "            a[i] = 1LL * a[i] * b[i] % mod;",
            "        }",
            "        ntt<mod, primitive_root>(a, true);",
            "        return a;",
            "    }",
            "",
            "    constexpr static int m[3] = {167772161, 469762049, 2013265921};        // mods",
            "    constexpr static int roots[3] = {3, 3, 31};                            // primitime roots for mods",
            "    constexpr static int64_t coeff[3] = {1, 167772161, 78812994116517889}; // coeff[i] = mul(m[0], ..., m[i - 1])",
            "    constexpr static int c_inv[3] = {1, 104391568, 1066314758};            // inv(coeff[i], mod m[i])",
            "",
            "public:",
            "    static vector<int64_t> multiply(vector<int> a, vector<int> b, int mod) {",
            "        vector<int> r[3]{",
            "            multiply<m[0], roots[0]>(a, b),",
            "            multiply<m[1], roots[1]>(a, b),",
            "            multiply<m[2], roots[2]>(a, b),",
            "        };",
            "",
            "        vector<int64_t> result(r[0].size());",
            "        for (int i = 0; i < r[0].size(); i++) {",
            "            __int128_t val = 0;",
            "            for (int j = 0; j < 3; j++) {",
            "                val += ((r[j][i] - val) % m[j] * c_inv[j] % m[j] + m[j]) % m[j] * coeff[j];",
            "            }",
            "            result[i] = (~mod ? val % mod : val);",
            "        }",
            "        return result;",
            "    }",
            "",
            "    static vector<int64_t> multiply(vector<int> a, vector<int> b) {",
            "        return multiply(a, b, -1);",
            "    }",
            "",
            "    static vector<int64_t> multiply(vector<int64_t> a, vector<int64_t> b, int mod) {",
            "        for (int i = 0; i < a.size(); ++i) {",
            "            a[i] %= mod;",
            "        }",
            "        for (int i = 0; i < b.size(); ++i) {",
            "            b[i] %= mod;",
            "        }",
            "        return multiply(vector<int>(a.begin(), a.end()), vector<int>(b.begin(), b.end()), mod);",
            "    }",
            "};",
            ""
        ],
        "description": "NTT"
    },
    "normal_NTT": {
        "prefix": "normal_NTT",
        "body": [
            "const int mod = 998244353, root = 3;",
            "int64_t power(int64_t a, int64_t b, const int MOD = mod) {",
            "    a %= MOD;",
            "    int64_t s = 1;",
            "    while (b) {",
            "        if (b % 2 == 1) {",
            "            s = s * a % MOD;",
            "        }",
            "        a = a * a % MOD;",
            "        b /= 2;",
            "    }",
            "    return s;",
            "}",
            "",
            "// Primitive Root of the mod of form 2^a * b + 1",
            "int generator() {",
            "    vector<int> fact;",
            "    int phi = mod - 1, n = phi;",
            "    for (int i = 2; i * i <= n; ++i)",
            "        if (n % i == 0) {",
            "            fact.push_back(i);",
            "            while (n % i == 0) {",
            "                n /= i;",
            "            }",
            "        }",
            "    if (n > 1) {",
            "        fact.push_back(n);",
            "    }",
            "    for (int res = 2; res <= mod; ++res) {",
            "        bool ok = true;",
            "        for (size_t i = 0; i < fact.size() && ok; ++i) {",
            "            ok &= power(res, phi / fact[i]) != 1;",
            "        }",
            "        if (ok) {",
            "            return res;",
            "        }",
            "    }",
            "    return -1;",
            "}",
            "",
            "class NTT {",
            "    static void ntt(vector<int64_t> &a) {",
            "        int n = (int)a.size(), L = 31 - __builtin_clz(n);",
            "        static vector<int64_t> rt(2, 1);                    // erase the static if you want to use two moduli;",
            "        for (static int k = 2, s = 2; k < n; k *= 2, s++) { // erase the static if you want to use two moduli;",
            "            rt.resize(n);",
            "            int64_t z[] = {1, power(root, mod >> s, mod)};",
            "            for (int i = k; i < 2 * k; ++i) {",
            "                rt[i] = rt[i / 2] * z[i & 1] % mod;",
            "            }",
            "        }",
            "        vector<int> rev(n);",
            "        for (int i = 0; i < n; ++i) {",
            "            rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "        }",
            "        for (int i = 0; i < n; ++i) {",
            "            if (i < rev[i]) {",
            "                swap(a[i], a[rev[i]]);",
            "            }",
            "        }",
            "        for (int k = 1; k < n; k *= 2) {",
            "            for (int i = 0; i < n; i += 2 * k) {",
            "                for (int j = 0; j < k; ++j) {",
            "                    int64_t z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];",
            "                    a[i + j + k] = ai - z + (z > ai ? mod : 0);",
            "                    ai += (ai + z >= mod ? z - mod : z);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    static vector<int64_t> conv(const vector<int64_t> &a, const vector<int64_t> &b) {",
            "        if (a.empty() || b.empty()) {",
            "            return {};",
            "        }",
            "        int s = (int)a.size() + (int)b.size() - 1, B = 32 - __builtin_clz(s), n = 1 << B;",
            "        int inv = power(n, mod - 2, mod);",
            "        vector<int64_t> L(a), R(b), out(n);",
            "        L.resize(n), R.resize(n);",
            "        ntt(L), ntt(R);",
            "        for (int i = 0; i < n; ++i) {",
            "            out[-i & (n - 1)] = (int64_t)L[i] * R[i] % mod * inv % mod;",
            "        }",
            "        ntt(out);",
            "        return {out.begin(), out.begin() + s};",
            "    }",
            "",
            "    static vector<int64_t> mul_polys(const vector<vector<int64_t>> &polys) {",
            "        if (polys.empty()) {",
            "            return {1};",
            "        }",
            "        function<vector<int64_t>(int, int)> solve = [&](int l, int r) {",
            "            if (l == r) {",
            "                return polys[l];",
            "            }",
            "            int mid = (l + r) / 2;",
            "            return conv(solve(l, mid), solve(mid + 1, r));",
            "        };",
            "        return solve(0, polys.size() - 1);",
            "    }",
            "",
            "    static vector<int64_t> poly_pow(vector<int64_t> poly, int64_t p) {",
            "        vector<int64_t> ans{1};",
            "        while (p) {",
            "            if (p & 1) {",
            "                ans = conv(ans, poly);",
            "            }",
            "            poly = conv(poly, poly);",
            "            p >>= 1;",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Notmal_NTT"
    },
    "FFT_MOD": {
        "prefix": "FFT_MOD",
        "body": [
            "using cd = complex<double>;",
            "const int MOD = 998244353, cut = sqrt(MOD);",
            "class FFT_MOD {",
            "    static void compute(vector<cd> &a) {",
            "        int n = a.size(), L = 31 - __builtin_clz(n);",
            "        vector<complex<long double>> R(2, 1);",
            "        vector<cd> rt(2, 1); // (^ 10% faster if double)",
            "        for (int k = 2; k < n; k <<= 1) {",
            "            R.resize(n);",
            "            rt.resize(n);",
            "            auto x = polar(1.0L, acos(-1.0L) / k);",
            "            for (int i = k; i < 2 * k; i++) {",
            "                rt[i] = R[i] = i & 1 ? R[i / 2] * x : R[i / 2];",
            "            }",
            "        }",
            "",
            "        vector<int64_t> rev(n);",
            "        for (int i = 0; i < n; i++) {",
            "            rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "        }",
            "",
            "        for (int i = 0; i < n; i++) {",
            "            if (i < rev[i]) {",
            "                swap(a[i], a[rev[i]]);",
            "            }",
            "        }",
            "        for (int k = 1; k < n; k <<= 1) {",
            "            for (int i = 0; i < n; i += (k << 1)) {",
            "                for (int j = 0; j < k; j++) {",
            "                    auto x = (double *)&rt[j + k], y = (double *)&a[i + j + k];",
            "                    cd z(x[0] * y[0] - x[1] * y[1], x[0] * y[1] + x[1] * y[0]);",
            "                    a[i + j + k] = a[i + j] - z;",
            "                    a[i + j] += z;",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    static vector<int64_t> mul(const vector<int64_t> &a, const vector<int64_t> &b) {",
            "        vector<int64_t> res(a.size() + b.size() - 1);",
            "        int B = 32 - __builtin_clz(res.size()), n = 1 << B;",
            "        vector<cd> L(n), R(n), outs(n), outl(n);",
            "        for (int i = 0; i < a.size(); i++) {",
            "            L[i] = cd((int)a[i] / cut, (int)a[i] % cut);",
            "        }",
            "        for (int i = 0; i < b.size(); i++) {",
            "            R[i] = cd((int)b[i] / cut, (int)b[i] % cut);",
            "        }",
            "",
            "        compute(L);",
            "        compute(R);",
            "",
            "        for (int i = 0; i < n; i++) {",
            "            int j = -i & (n - 1);",
            "            outl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);",
            "            outs[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;",
            "        }",
            "",
            "        compute(outl);",
            "        compute(outs);",
            "",
            "        for (int i = 0; i < res.size(); i++) {",
            "            int64_t av = int64_t(real(outl[i]) + .5), cv = int64_t(imag(outs[i]) + .5);",
            "            int64_t bv = int64_t(imag(outl[i]) + .5) + int64_t(real(outs[i]) + .5);",
            "            res[i] = ((av % MOD * cut + bv) % MOD * cut + cv) % MOD;",
            "        }",
            "        return res;",
            "    }",
            "};",
            ""
        ],
        "description": "FFT_MOD"
    },
    "classic_NTT": {
        "prefix": "classic_NTT",
        "body": [
            "const int mod = 998244353, root = 3;",
            "int64_t power(int64_t a, int64_t b, const int MOD = mod) {",
            "    a %= MOD;",
            "    int64_t s = 1;",
            "    while (b) {",
            "        if (b % 2 == 1) {",
            "            s = s * a % MOD;",
            "        }",
            "        a = a * a % MOD;",
            "        b /= 2;",
            "    }",
            "    return s;",
            "}",
            "",
            "// Primitive Root of the mod of form 2^a * b + 1",
            "int generator() {",
            "    vector<int> fact;",
            "    int phi = mod - 1, n = phi;",
            "    for (int i = 2; i * i <= n; ++i)",
            "        if (n % i == 0) {",
            "            fact.push_back(i);",
            "            while (n % i == 0) {",
            "                n /= i;",
            "            }",
            "        }",
            "    if (n > 1) {",
            "        fact.push_back(n);",
            "    }",
            "    for (int res = 2; res <= mod; ++res) {",
            "        bool ok = true;",
            "        for (size_t i = 0; i < fact.size() && ok; ++i) {",
            "            ok &= power(res, phi / fact[i]) != 1;",
            "        }",
            "        if (ok) {",
            "            return res;",
            "        }",
            "    }",
            "    return -1;",
            "}",
            "",
            "class NTT {",
            "    static void ntt(vector<int64_t> &a) {",
            "        int n = (int)a.size(), L = 31 - __builtin_clz(n);",
            "        static vector<int64_t> rt(2, 1);                    // erase the static if you want to use two moduli;",
            "        for (static int k = 2, s = 2; k < n; k *= 2, s++) { // erase the static if you want to use two moduli;",
            "            rt.resize(n);",
            "            int64_t z[] = {1, power(root, mod >> s, mod)};",
            "            for (int i = k; i < 2 * k; ++i) {",
            "                rt[i] = rt[i / 2] * z[i & 1] % mod;",
            "            }",
            "        }",
            "        vector<int> rev(n);",
            "        for (int i = 0; i < n; ++i) {",
            "            rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "        }",
            "        for (int i = 0; i < n; ++i) {",
            "            if (i < rev[i]) {",
            "                swap(a[i], a[rev[i]]);",
            "            }",
            "        }",
            "        for (int k = 1; k < n; k *= 2) {",
            "            for (int i = 0; i < n; i += 2 * k) {",
            "                for (int j = 0; j < k; ++j) {",
            "                    int64_t z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];",
            "                    a[i + j + k] = ai - z + (z > ai ? mod : 0);",
            "                    ai += (ai + z >= mod ? z - mod : z);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    static vector<int64_t> conv(const vector<int64_t> &a, const vector<int64_t> &b) {",
            "        if (a.empty() || b.empty()) {",
            "            return {};",
            "        }",
            "        int s = (int)a.size() + (int)b.size() - 1, B = 32 - __builtin_clz(s), n = 1 << B;",
            "        int inv = power(n, mod - 2, mod);",
            "        vector<int64_t> L(a), R(b), out(n);",
            "        L.resize(n), R.resize(n);",
            "        ntt(L), ntt(R);",
            "        for (int i = 0; i < n; ++i) {",
            "            out[-i & (n - 1)] = (int64_t)L[i] * R[i] % mod * inv % mod;",
            "        }",
            "        ntt(out);",
            "        return {out.begin(), out.begin() + s};",
            "    }",
            "",
            "    static vector<int64_t> mul_polys(const vector<vector<int64_t>> &polys) {",
            "        if (polys.empty()) {",
            "            return {1};",
            "        }",
            "        function<vector<int64_t>(int, int)> solve = [&](int l, int r) {",
            "            if (l == r) {",
            "                return polys[l];",
            "            }",
            "            int mid = (l + r) / 2;",
            "            return conv(solve(l, mid), solve(mid + 1, r));",
            "        };",
            "        return solve(0, polys.size() - 1);",
            "    }",
            "",
            "    static vector<int64_t> poly_pow(vector<int64_t> poly, int64_t p) {",
            "        vector<int64_t> ans{1};",
            "        while (p) {",
            "            if (p & 1) {",
            "                ans = conv(ans, poly);",
            "            }",
            "            poly = conv(poly, poly);",
            "            p >>= 1;",
            "        }",
            "        return ans;",
            "    }",
            "};",
            ""
        ],
        "description": "classic_NTT"
    },
    "generate_tree": {
        "prefix": "generate_tree",
        "body": [
            "vector<pair<int, int>> generate_tree(int n) {",
            "    vector<pair<int, int>> edges;",
            "    for (int i = 2; i <= n; ++i) {",
            "        int u = rand(1, i - 1);",
            "        edges.emplace_back(u, i);",
            "    }",
            "    return edges;",
            "}"
        ],
        "description": "generate_tree"
    },
    "GCD_Convolution": {
        "prefix": "GCD_Convolution",
        "body": [
            "// 1-based",
            "class GCD_Convolution {",
            "    template <class T>",
            "    static void _gcd_zeta(vector<T> &v) {",
            "        int n = v.size() - 1;",
            "        vector<bool> sieve(n + 1, true);",
            "        for (int64_t i = 2; i <= n; i++) {",
            "            if (sieve[i]) {",
            "                for (int64_t j = n / i; j >= 1; j--)",
            "                    v[j] += v[i * j];",
            "                for (int64_t j = i * i; j <= n; j += i)",
            "                    sieve[j] = false;",
            "            }",
            "        }",
            "    }",
            "",
            "    template <class T>",
            "    static void _gcd_mobius(vector<T> &v) {",
            "        int n = v.size() - 1;",
            "        vector<bool> sieve(n + 1, true);",
            "        for (int64_t i = 2; i <= n; i++) {",
            "            if (sieve[i]) {",
            "                for (int64_t j = 1; j <= n / i; j++)",
            "                    v[j] -= v[i * j];",
            "                for (int64_t j = i * i; j <= n; j += i)",
            "                    sieve[j] = false;",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    template <class T>",
            "    static vector<T> multiply(vector<T> A, vector<T> B) {",
            "        int n = max(A.size(), B.size());",
            "        A.resize(n), B.resize(n);",
            "        _gcd_zeta(A);",
            "        _gcd_zeta(B);",
            "        for (int i = 0; i < n; i++)",
            "            A[i] *= B[i];",
            "        _gcd_mobius(A);",
            "        return A;",
            "    }",
            "};",
            ""
        ],
        "description": "GCD_Convolution"
    },
    "LCM_Convolution": {
        "prefix": "LCM_Convolution",
        "body": [
            "// 1-based",
            "class LCM_Convolution {",
            "    /* Linear Sieve, O(n) */",
            "    static vector<int> PrimeEnumerate(int n) {",
            "        vector<int> P;",
            "        vector<bool> B(n + 1, 1);",
            "        for (int i = 2; i <= n; i++) {",
            "            if (B[i])",
            "                P.push_back(i);",
            "            for (int j : P) {",
            "                if (i * j > n)",
            "                    break;",
            "                B[i * j] = 0;",
            "                if (i % j == 0)",
            "                    break;",
            "            }",
            "        }",
            "        return P;",
            "    }",
            "",
            "    template <typename T>",
            "    static void DivisorZetaTransform(vector<T> &v) {",
            "        const int n = (int)v.size() - 1;",
            "        for (int p : PrimeEnumerate(n)) {",
            "            for (int i = 1; i * p <= n; i++)",
            "                v[i * p] += v[i];",
            "        }",
            "    }",
            "",
            "    template <typename T>",
            "    static void DivisorMobiusTransform(vector<T> &v) {",
            "        const int n = (int)v.size() - 1;",
            "        for (int p : PrimeEnumerate(n)) {",
            "            for (int i = n / p; i; i--)",
            "                v[i * p] -= v[i];",
            "        }",
            "    }",
            "",
            "public:",
            "    template <typename T>",
            "    static vector<T> multiply(vector<T> A, vector<T> B) {",
            "        int n = max(A.size(), B.size());",
            "        A.resize(n), B.resize(n);",
            "",
            "        DivisorZetaTransform(A);",
            "        DivisorZetaTransform(B);",
            "        for (int i = 0; i < n; i++)",
            "            A[i] *= B[i];",
            "        DivisorMobiusTransform(A);",
            "        return A;",
            "    }",
            "};",
            ""
        ],
        "description": "LCM_Convolution"
    },
    "fwht": {
        "prefix": "fwht",
        "body": [
            "class fwht {",
            "public:",
            "    enum Mode {",
            "        XOR,",
            "        AND,",
            "        OR,",
            "    };",
            "",
            "private:",
            "    template <typename T>",
            "    static void hadamard(vector<T> &a, int inv, Mode mode) {",
            "        int n = a.size();",
            "        for (int k = 1; k < n; k <<= 1) {",
            "            for (int i = 0; i < n; i += 2 * k) {",
            "                for (int j = 0; j < k; j++) {",
            "                    T x = a[i + j];",
            "                    T y = a[i + j + k];",
            "",
            "                    if (mode == XOR) {",
            "                        a[i + j] = x + y;",
            "                        a[i + j + k] = x - y;",
            "                    }",
            "                    else if (mode == AND) {",
            "                        if (!inv) {",
            "                            a[i + j] = y, a[i + j + k] = x + y;",
            "                        }",
            "                        else {",
            "                            a[i + j] = y - x, a[i + j + k] = x;",
            "                        }",
            "                    }",
            "                    else if (mode == OR) {",
            "                        if (!inv) {",
            "                            a[i + j + k] = x + y;",
            "                        }",
            "                        else {",
            "                            a[i + j + k] = y - x;",
            "                        }",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    template <typename T>",
            "    static vector<T> multiply(vector<T> a, vector<T> b, Mode mode) {",
            "        int n = 1;",
            "        while (n < (int)max(a.size(), b.size())) {",
            "            n <<= 1;",
            "        }",
            "        a.resize(n);",
            "        b.resize(n);",
            "",
            "        hadamard(a, 0, mode);",
            "        hadamard(b, 0, mode);",
            "        for (int i = 0; i < n; i++) {",
            "            a[i] *= b[i];",
            "        }",
            "        hadamard(a, 1, mode);",
            "        if (mode == XOR) {",
            "            for (int i = 0; i < n; i++) {",
            "                a[i] /= n;",
            "            }",
            "        }",
            "        return a;",
            "    }",
            "};",
            ""
        ],
        "description": "fwht"
    },
    "xor_basis": {
        "prefix": "xor_basis",
        "body": [
            "template <int LOG = 62>",
            "class xor_basis {",
            "    int elements = 0, sz = 0;",
            "    int64_t basis[LOG] = {};",
            "",
            "    int64_t power(int64_t n, int64_t p, int64_t mod) {",
            "        return (p ? ((p & 1) ? n % mod : 1) * power(n % mod * n % mod, p / 2, mod) % mod : 1);",
            "    }",
            "",
            "public:",
            "    void insert(int64_t mask) {",
            "        elements++;",
            "        for (int i = LOG - 1; ~i; --i) {",
            "            if (mask & (1LL << i)) {",
            "                if (!basis[i]) {",
            "                    basis[i] = mask;",
            "                    ++sz;",
            "",
            "                    for (int j = i - 1; j >= 0; --j) {",
            "                        if (basis[j] && (basis[i] & (1LL << j))) {",
            "                            basis[i] ^= basis[j];",
            "                        }",
            "                    }",
            "                    for (int j = i + 1; j < LOG; ++j) {",
            "                        if (basis[j] & (1LL << i)) {",
            "                            basis[j] ^= basis[i];",
            "                        }",
            "                    }",
            "",
            "                    return;",
            "                }",
            "                mask ^= basis[i];",
            "            }",
            "        }",
            "    }",
            "",
            "    int64_t distinct_xors() {",
            "        return 1LL << sz;",
            "    }",
            "",
            "    int64_t max_xor() {",
            "        int64_t ret = 0;",
            "        for (int i = LOG - 1; ~i; --i) {",
            "            ret = max(ret, ret ^ basis[i]);",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    int64_t count(int64_t x, int64_t mod) {",
            "        for (int i = LOG - 1; ~i; --i) {",
            "            if (x & (1LL << i)) {",
            "                x ^= basis[i];",
            "            }",
            "        }",
            "        return !x * power(2, elements - sz, mod);",
            "    }",
            "",
            "    int64_t kth_xor(int64_t k) {",
            "        if (elements - sz > __lg(k)) {",
            "            return 0;",
            "        }",
            "        k--, k /= (int64_t)(powl(2, elements - sz));",
            "        if (k >= distinct_xors()) {",
            "            return -1;",
            "        }",
            "        int64_t ans = 0;",
            "        for (int i = 0, pos = 0; i < LOG; ++i) {",
            "            if (basis[i]) {",
            "                if (k & (1LL << pos++)) {",
            "                    ans ^= basis[i];",
            "                }",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "};",
            "",
            ""
        ],
        "description": "xor_basis"
    },
    "xor_basis_trick": {
        "prefix": "xor_basis_trick",
        "body": [
            "const int LOG = 60;",
            "class xor_basis {",
            "public:",
            "    int sz = 0, last[LOG];",
            "    int64_t basis[LOG] = {};",
            "",
            "    xor_basis() { memset(last, -1, sizeof(last)); }",
            "    void insert(int64_t mask, int id = 1e9) {",
            "        for (int64_t i = LOG - 1; ~i; --i) {",
            "            if (mask & (1LL << i)) {",
            "                if (id > last[i]) {",
            "                    swap(basis[i], mask);",
            "                    swap(last[i], id);",
            "                }",
            "                mask ^= basis[i];",
            "            }",
            "        }",
            "    }",
            "",
            "    bool can(int64_t x, int id) {",
            "        for (int i = LOG - 1; ~i; --i) {",
            "            if ((x >> i & 1) && last[i] >= id) {",
            "                x ^= basis[i];",
            "            }",
            "        }",
            "        return !x;",
            "    }",
            "};",
            ""
        ],
        "description": "xor_basis_trick"
    },
    "factors": {
        "prefix": "factors",
        "body": [
            "vector<int64_t> factors(int64_t n) {",
            "    vector<int64_t> fact;",
            " ",
            "    for (int64_t i = 2; i <= n / i; ++i) {",
            "        if (n % i == 0) {",
            "            fact.emplace_back(i);",
            "            while (n % i == 0) {",
            "                n /= i;",
            "            }",
            "        }",
            "    }",
            "    if (n > 1) {",
            "        fact.emplace_back(n);",
            "    }",
            " ",
            "    return fact;",
            "}",
            ""
        ],
        "description": "factors"
    },
    "basis_notes": {
        "prefix": "basis_notes",
        "body": [
            "/*",
            "    int n;",
            "    cin >> n;",
            "",
            "    int64_t total = 0;",
            "    vector<int64_t> v(n);",
            "    for (auto &it : v) {",
            "        cin >> it;",
            "        total ^= it;",
            "    }",
            "",
            "    xor_basis<60> xb;",
            "    for (auto &it : v) {",
            "        xb.insert((~total) & it);",
            "    }",
            "    cout << total + 2 * xb.max_xor();",
            "*/"
        ],
        "description": "basis_notes"
    },
    "inclusion_exclusion": {
        "prefix": "inclusion_exclusion",
        "body": [
            "int64_t inclusion_exclusion(int64_t n, const vector<int> &fact) {",
            "    int sz = (int)fact.size();",
            "    int64_t ret = 0;",
            "    for (int64_t mask = 1; mask < (1 << sz); ++mask) {",
            "        int64_t lc = 1;",
            "        for (int64_t bit = 0; bit < sz; ++bit) {",
            "            if ((1 << bit) & mask) {",
            "                lc = lcm(lc, fact[bit]);",
            "            }",
            "        }",
            "",
            "        if (__builtin_popcount(mask) & 1) {",
            "            ret += n / lc;",
            "        } else {",
            "            ret -= n / lc;",
            "        }",
            "    }",
            "    return n - ret;",
            "}"
        ],
        "description": "inclusion_exclusion"
    },
    "nCr": {
        "prefix": "nCr",
        "body": [
            "const int N = 2e5 + 5, R = 5;",
            "uint64_t ncr[N][R];",
            "auto calc = []() {",
            "    ncr[0][0] = 1;",
            "    for (int n = 1; n < N; ++n) {",
            "        ncr[n][0] = 1;",
            "        for (int r = 1; r < R; ++r) {",
            "            ncr[n][r] = ncr[n - 1][r - 1] + ncr[n - 1][r];",
            "        }",
            "    }",
            "    return 0;",
            "}();"
        ],
        "description": "nCr"
    },
    "dx_dy": {
        "prefix": "dx_dy",
        "body": [
            "const int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};",
            "const int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};"
        ],
        "description": "dx_dy"
    },
    "prefix_2D": {
        "prefix": "prefix_2D",
        "body": [
            "    vector pref(n + 5, vector<int64_t>(n + 5, 0));",
            "    for (int i = 1; i < n; ++i) {",
            "        for (int j = 0; j < n; ++j) {",
            "            pref[i][j] += pref[i - 1][j];",
            "        }",
            "    }",
            "",
            "    for (int j = 1; j < n; ++j) {",
            "        for (int i = 0; i < n; ++i) {",
            "            pref[i][j] += pref[i][j - 1];",
            "        }",
            "    }",
            "    auto get = [&](int x, int y, int x2, int y2) -> int64_t {",
            "        return pref[x2][y2] - pref[x - 1][y2] - pref[x2][y - 1] + pref[x - 1][y - 1];",
            "    };"
        ],
        "description": "prefix_2D"
    },
    "mex_simple": {
        "prefix": "mex_simple",
        "body": [
            "int mex(auto &container) {",
            "    int n = container.size();",
            "    vector<int> frq(n);",
            "    for (auto it : container) {",
            "        if (it < n) {",
            "            frq[it] = 1;",
            "        }",
            "    }",
            "",
            "    for (int i = 0; i < n; ++i) {",
            "        if (!frq[i]) {",
            "            return i;",
            "        }",
            "    }",
            "    return n;",
            "}"
        ],
        "description": "mex_simple"
    },
    "Mo_Tree": {
        "prefix": "Mo_Tree",
        "body": [
            "template <class M, bool val_on_edge = false>",
            "class Mo_Tree {",
            "private:",
            "    static inline int64_t hilbertOrder(int x, int y, int pow, int rotate) {",
            "        if (pow == 0)",
            "            return 0;",
            "        int hpow = 1 << (pow - 1);",
            "        int seg = (x < hpow) ? ((y < hpow) ? 0 : 3) : ((y < hpow) ? 1 : 2);",
            "        seg = (seg + rotate) & 3;",
            "        const int rotateDelta[4] = {3, 0, 0, 1};",
            "        int nx = x & (x ^ hpow), ny = y & (y ^ hpow);",
            "        int nrot = (rotate + rotateDelta[seg]) & 3;",
            "        int64_t subSquareSize = int64_t(1) << (2 * pow - 2);",
            "        int64_t ordd = seg * subSquareSize;",
            "        int64_t add = hilbertOrder(nx, ny, pow - 1, nrot);",
            "        ordd += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);",
            "        return ordd;",
            "    }",
            "",
            "    struct query {",
            "        int l, r, q_indx, lc;",
            "        int64_t ord;",
            "    };",
            "",
            "    int q;",
            "    vector<int> depth, flat, st, en, node_freq;",
            "    vector<vector<int>> anc;",
            "    vector<M> v;",
            "    vector<query> Q;",
            "    void add_node(int node) {",
            "    }",
            "",
            "    void remove_node(int node) {",
            "    }",
            "",
            "    long long calc(...) {",
            "        return m.get_mex();",
            "    }",
            "",
            "    void add(int ind) {",
            "        node_freq[flat[ind]]++;",
            "        if (node_freq[flat[ind]] == 1) {",
            "            add_node(flat[ind]);",
            "        } else {",
            "            remove_node(flat[ind]);",
            "        }",
            "    }",
            "",
            "    void remove(int ind) {",
            "        node_freq[flat[ind]]--;",
            "        if (node_freq[flat[ind]] == 1) {",
            "            add_node(flat[ind]);",
            "        } else {",
            "            remove_node(flat[ind]);",
            "        }",
            "    }",
            "",
            "public:",
            "    Mo_Tree(vector<vector<int>> &g, const vector<M> &v) {",
            "        q = 0;",
            "        this->v = v;",
            "        int n = (int)g.size() - 1;",
            "        depth.resize(n + 1), st.resize(n + 1);",
            "        en.resize(n + 1), node_freq.resize(n + 1);",
            "        anc.assign(n + 1, vector<int>(__lg(n) + 2, 0));",
            "",
            "        function<void(int, int, int)> dfs = [&](int node, int p, int d) {",
            "            anc[node][0] = p;",
            "            depth[node] = d;",
            "            st[node] = flat.size();",
            "            flat.push_back(node);",
            "            for (auto it : g[node]) {",
            "                if (it != p) {",
            "                    dfs(it, node, d + 1);",
            "                }",
            "            }",
            "            en[node] = flat.size();",
            "            flat.push_back(node);",
            "        };",
            "        dfs(1, 0, 0);",
            "",
            "        for (int j = 1; j <= __lg(n); ++j) {",
            "            for (int i = 1; i <= n; ++i) {",
            "                anc[i][j] = anc[anc[i][j - 1]][j - 1];",
            "            }",
            "        }",
            "    }",
            "",
            "    int kth_anc(int node, int k) {",
            "        int ret = node;",
            "        for (int bit = (int)anc[ret].size() - 1; ~bit; --bit) {",
            "            if (k & (1 << bit)) {",
            "                ret = anc[ret][bit];",
            "            }",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    int lca(int u, int v) {",
            "        if (depth[u] < depth[v]) {",
            "            swap(u, v);",
            "        }",
            "        u = kth_anc(u, depth[u] - depth[v]);",
            "        if (u == v) {",
            "            return u;",
            "        }",
            "        for (int bit = anc[0].size() - 1; ~bit; --bit) {",
            "            if (anc[u][bit] != anc[v][bit]) {",
            "                u = anc[u][bit];",
            "                v = anc[v][bit];",
            "            }",
            "        }",
            "        return anc[u][0];",
            "    }",
            "",
            "    template <class... T>",
            "    void add_query(int u, int v, T &...x) {",
            "        if (st[u] > st[v]) {",
            "            swap(u, v);",
            "        }",
            "        int lc = lca(u, v), l, r, lc_ = -1;",
            "        if (lc == u || lc == v) {",
            "            l = st[u] + val_on_edge, r = st[v];",
            "        } else {",
            "            l = en[u], r = st[v], lc_ = lc;",
            "        }",
            "        Q.push_back({l, r, q++, lc_, hilbertOrder(l, r, __lg(flat.size()) + 1, 0), x...});",
            "    }",
            "",
            "    void mo_process() {",
            "        vector<long long> ans(q);",
            "",
            "        sort(Q.begin(), Q.end(), [&](query a, query b) {",
            "            return a.ord < b.ord;",
            "        });",
            "",
            "        int l = 0, r = -1;",
            "        for (auto [L, R, q_indx, lc, ord] : Q) {",
            "            while (l > L)",
            "                add(--l);",
            "            while (r < R)",
            "                add(++r);",
            "            while (r > R)",
            "                remove(r--);",
            "            while (l < L)",
            "                remove(l++);",
            "",
            "            if (~lc && !val_on_edge)",
            "                add_node(lc);",
            "            ans[q_indx] = calc();",
            "            if (~lc && !val_on_edge)",
            "                remove_node(lc);",
            "        }",
            "",
            "        for (auto it : ans) {",
            "            cout << it << '\\n';",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "Mo_Tree"
    },
    "ternary_search_mn": {
        "prefix": "ternary_search_mn",
        "body": [
            "    // local mn",
            "    auto f = [&](int64_t x) {",
            "        return x;",
            "    };",
            "",
            "    int64_t l =, r =, ans;",
            "    while (l <= r) { // 2 1 2",
            "        int64_t m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;",
            "",
            "        if (f(m1) < f(m2)) {",
            "            r = m2 - 1, ans = m1;",
            "        } else {",
            "            l = m1 + 1, ans = m2;",
            "        }",
            "    }"
        ],
        "description": "ternary_search_mn"
    },
    "ternary_search_mx": {
        "prefix": "ternary_search_mx",
        "body": [
            "    // local mx",
            "    auto f = [&](int64_t x) {",
            "        return x;",
            "    };",
            "",
            "    int64_t l =, r =, ans;",
            "    while (l <= r) { // 1 2 1",
            "        int64_t m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;",
            "",
            "        if (f(m1) > f(m2)) {",
            "            r = m2 - 1, ans = m1;",
            "        } else {",
            "            l = m1 + 1, ans = m2;",
            "        }",
            "    }"
        ],
        "description": "ternary_search_mx"
    },
    "vin": {
        "prefix": "vin",
        "body": [
            "int n;",
            "cin >> n;",
            "",
            "vector<int> v(n);",
            "for (int i = 0; i < n; ++i) {",
            "    cin >> v[i];",
            "}"
        ],
        "description": "vin"
    },
    "files": {
        "prefix": "files",
        "body": [
            "cin.tie(nullptr)->sync_with_stdio(false);",
            "if (fopen(\"in.txt\", \"r\")) {",
            "    freopen(\"in.txt\", \"r\", stdin);",
            "    freopen(\"out.txt\", \"w\", stdout);",
            "}"
        ],
        "description": "files"
    },
    "mono_stack": {
        "prefix": "mono_stack",
        "body": [
            "/*",
            " * next/prev greater       ---> mono_stack<int, greater<int>>",
            " * next/prev less          ---> mono_stack<int, less<int>>",
            " * next/prev greater_equal ---> mono_stack<int, greater_equal<int>>",
            " * next/prev less_equal    ---> mono_stack<int, less_equal<int>>",
            " */",
            "template <class T, class compare = less<T>>",
            "class mono_stack {",
            "public:",
            "    vector<T> next, prev;",
            "    mono_stack(const vector<T> &v) {",
            "        int n = v.size();",
            "        next.assign(n, n);",
            "        prev.assign(n, -1);",
            "",
            "        stack<int> a, b;",
            "        compare cmp = compare();",
            "        for (int i = 0; i < n; i++) {",
            "            while (!a.empty() && cmp(v[i], v[a.top()])) {",
            "                next[a.top()] = i;",
            "                a.pop();",
            "            }",
            "            a.push(i);",
            "        }",
            "",
            "        for (int i = n - 1; ~i; i--) {",
            "            while (!b.empty() && cmp(v[i], v[b.top()])) {",
            "                prev[b.top()] = i;",
            "                b.pop();",
            "            }",
            "            b.push(i);",
            "        }",
            "    }",
            "",
            "    pair<vector<T>, vector<T>> get() {",
            "        return pair{prev, next};",
            "    }",
            "};",
            ""
        ],
        "description": "mono_stack"
    },
    "num_divs_cbrt": {
        "prefix": "num_divs_cbrt",
        "body": [
            "namespace sieve {",
            "    auto primes(int N) {",
            "        vector<int> _primes;",
            "        vector<bool> _is_prime(N + 1, 1);",
            "        _is_prime[0] = _is_prime[1] = 0;",
            "        for (int64_t i = 1; i <= N; i++) {",
            "            if (_is_prime[i]) {",
            "                _primes.emplace_back(i);",
            "            }",
            "            for (auto it : _primes) {",
            "                if (i * it > N) {",
            "                    break;",
            "                }",
            "                _is_prime[i * it] = 0;",
            "                if (i % it == 0) {",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "        return _primes;",
            "    }",
            "}",
            "auto primes = sieve::primes(2e6);",
            "",
            "using u128 = __uint128_t;",
            "using u64 = uint64_t;",
            "",
            "u64 rand(u64 l, u64 r) {",
            "    static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "    return uniform_int_distribution<u64>(l, r)(rng);",
            "}",
            "",
            "namespace primallity {",
            "    u64 mulmod(u64 a, u64 b, const u64 mod) {",
            "        return (u128)a * b % mod;",
            "    }",
            "",
            "    u64 power(u64 base, u64 e, const u64 mod) {",
            "        u64 result = 1;",
            "        base %= mod;",
            "        while (e) {",
            "            if (e & 1) {",
            "                result = mulmod(result, base, mod);",
            "            }",
            "            base = mulmod(base, base, mod);",
            "            e >>= 1;",
            "        }",
            "        return result;",
            "    }",
            "",
            "    bool check_composite(u64 n, u64 a, u64 d, int s) {",
            "        u64 x = power(a, d, n);",
            "        if (x == 1 || x == n - 1) {",
            "            return false;",
            "        }",
            "        for (int r = 1; r < s; r++) {",
            "            x = mulmod(x, x, n);",
            "            if (x == n - 1) {",
            "                return false;",
            "            }",
            "        }",
            "        return true;",
            "    };",
            "}",
            "",
            "bool is_prime(u64 n, int iter = 5) {",
            "    if (n < 4) {",
            "        return n == 2 || n == 3;",
            "    }",
            "    int s = 0;",
            "    u64 d = n - 1;",
            "    while ((d & 1) == 0) {",
            "        d >>= 1;",
            "        s++;",
            "    }",
            "    for (int i = 0; i < iter; i++) {",
            "        u64 a = rand(2, n - 2);",
            "        if (primallity::check_composite(n, a, d, s)) {",
            "            return false;",
            "        }",
            "    }",
            "    return true;",
            "}",
            "",
            "/**",
            " * @brief Counts the number of divisors of N using the O(N^(1/3)) optimized method.",
            " */",
            "int64_t count_divisors(int64_t N) {",
            "    if (N <= 0) {",
            "        return 0;",
            "    }",
            "    if (N == 1) {",
            "        return 1;",
            "    }",
            "",
            "    int64_t ans = 1;",
            "    int64_t temp_N = N;",
            "",
            "    for (int p : primes) {",
            "        if ((int64_t)p * p * p > temp_N) {",
            "            break;",
            "        }",
            "        int count = 0;",
            "        if (temp_N % p == 0) {",
            "            while (temp_N % p == 0) {",
            "                temp_N /= p;",
            "                count++;",
            "            }",
            "            ans *= (count + 1);",
            "        }",
            "    }",
            "",
            "    if (temp_N == 1) {",
            "        goto done;",
            "    } else if (is_prime(temp_N)) {",
            "        ans *= 2;",
            "    } else {",
            "        int64_t root_n = round(sqrtl(temp_N));",
            "        if (root_n * root_n == temp_N && is_prime(root_n)) {",
            "            ans *= 3;",
            "        } else {",
            "            ans *= 4;",
            "        }",
            "    }",
            "done:;",
            "    return ans;",
            "}"
        ],
        "description": "num_divs_cbrt"
    },
    "inverse": {
        "prefix": "inverse",
        "body": [
            "template <typename T>",
            "T inverse(T a, T MOD = mod) {",
            "    T u = 0, v = 1;",
            "    while (a != 0) {",
            "        T t = MOD / a;",
            "        MOD -= t * a;",
            "        swap(a, MOD);",
            "        u -= t * v;",
            "        swap(u, v);",
            "    }",
            "    return u;",
            "}"
        ],
        "description": "inverse"
    },
    "linear_phi": {
        "prefix": "linear_phi",
        "body": [
            "const int N = 1E7;",
            "int phi[N + 1]{}, spf[N + 1]{};",
            "void calc() {",
            "    vector<int> primes;",
            "    for (int i = 1; i <= N; ++i) {",
            "        spf[i] = phi[i] = i;",
            "    }",
            "    for (int64_t i = 2; i <= N; i++) {",
            "        if (spf[i] == i) {",
            "            primes.emplace_back(i);",
            "            phi[i] = i - 1;",
            "        }",
            "        for (auto pr : primes) {",
            "            if (1LL * i * pr > N) {",
            "                break;",
            "            }",
            "            spf[i * pr] = min(pr, spf[i]);",
            "            if (i % pr == 0) {",
            "                phi[i * pr] = phi[i] * pr;",
            "                break;",
            "            } else {",
            "                phi[i * pr] = phi[i] * phi[pr];",
            "            }",
            "        }",
            "    }",
            "}",
            ""
        ],
        "description": "linear_phi"
    },
    "int128": {
        "prefix": "int128",
        "body": [
            "using i128 = __int128_t;",
            "istream &operator>>(istream &in, i128 &x) {",
            "    string s;",
            "    int sign = 1;",
            "    cin >> s, x = 0;",
            "    for (auto c : s) {",
            "        if (c == '-') {",
            "            sign = -1;",
            "        } else {",
            "            x = x * 10 + sign * (c - '0');",
            "        }",
            "    }",
            "    return in;",
            "}",
            "",
            "ostream &operator<<(ostream &out, i128 x) {",
            "    if (x < 0) {",
            "        out << '-';",
            "        x = -x;",
            "    }",
            "",
            "    if (x / 10) out << x / 10;",
            "    return out << (int)(x % 10);",
            "}"
        ],
        "description": "int128"
    },
    "phi": {
        "prefix": "phi",
        "body": [
            "int64_t phi(int64_t n) {",
            "    int64_t ans = n;",
            "    for (int64_t p = 2; p <= n / p; p++) {",
            "        if (n % p == 0) {",
            "            while (n % p == 0) {",
            "                n /= p;",
            "            }",
            "            ans -= ans / p;",
            "        }",
            "    }",
            "    if (n > 1) {",
            "        ans -= ans / n;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "phi"
    },
    "mobius": {
        "prefix": "mobius",
        "body": [
            "int mobius(int64_t n) {",
            "    if (n == 1) {",
            "        return 1;",
            "    }",
            "    int ans = 1;",
            "    for (int i = 2; i <= n / i; ++i) {",
            "        if (n % i == 0) {",
            "            if (n % (i * i) == 0) {",
            "                return 0;",
            "            }",
            "            n /= i, ans = -ans;",
            "        }",
            "    }",
            "    if (n) {",
            "        ans = -ans;",
            "    }",
            "    return ans;",
            "}",
            ""
        ],
        "description": "mobius"
    },
}